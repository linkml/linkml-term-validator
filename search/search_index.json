{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"linkml-term-validator","text":"<p>Validating LinkML schemas and datasets that depend on external ontology terms</p> <p>A collection of LinkML ValidationPlugin implementations for validating ontology term references in schemas and data.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u2705 Three composable validation plugins for the LinkML validator framework</li> <li>\u2705 Schema validation - Validates <code>meaning</code> fields in enum permissible values</li> <li>\u2705 Dynamic enum validation - Validates data against <code>reachable_from</code>, <code>matches</code>, <code>concepts</code></li> <li>\u2705 Binding validation - Validates constraints on nested object fields</li> <li>\u2705 Multi-level caching - In-memory + file-based for fast repeated validation</li> <li>\u2705 Ontology Access Kit (OAK) integration - Supports multiple ontology sources</li> <li>\u2705 AI hallucination prevention - Dual validation (ID + label) for AI-generated terms</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install linkml-term-validator\n</code></pre>"},{"location":"#validate-a-schema","title":"Validate a Schema","text":"<p>Check that <code>meaning</code> fields reference valid ontology terms:</p> <pre><code>linkml-term-validator validate-schema schema.yaml\n</code></pre>"},{"location":"#validate-data","title":"Validate Data","text":"<p>Validate data instances against dynamic enums and binding constraints:</p> <pre><code>linkml-term-validator validate-data data.yaml --schema schema.yaml\n</code></pre>"},{"location":"#documentation-quick-links","title":"Documentation Quick Links","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Getting Started Tutorial - Interactive notebook for CLI basics</li> <li>CLI Reference - Complete command-line documentation</li> <li>Configuration - Configure ontology adapters and caching</li> </ul>"},{"location":"#understanding-validation","title":"Understanding Validation","text":"<ul> <li>Validation Types - Schema, dynamic enum, and binding validation explained</li> <li>Anti-Hallucination Guardrails - Preventing AI from hallucinating ontology IDs</li> <li>Ontology Access - How OAK adapters work</li> </ul>"},{"location":"#integration","title":"Integration","text":"<ul> <li>linkml-validate Integration - Use plugins with standard linkml-validate</li> <li>Python API - Programmatic usage</li> <li>Plugin Reference - Complete API documentation</li> </ul>"},{"location":"#advanced-topics","title":"Advanced Topics","text":"<ul> <li>TSV/CSV Data Validation - Validating tabular data</li> <li>Advanced Usage - Custom configs, local files, troubleshooting</li> <li>Caching - Understanding the caching system</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Schema Quality Assurance - Catch typos and mismatches in ontology term references before publishing</li> <li>Data Validation - Ensure curated datasets only use valid, constrained ontology terms</li> <li>AI-Generated Content - Prevent language models from hallucinating fake ontology identifiers</li> <li>CI/CD Integration - Automated validation in continuous integration pipelines</li> <li>Flexible Constraints - Define valid terms via ontology queries rather than hardcoded lists</li> </ul>"},{"location":"anti-hallucination/","title":"Anti-Hallucination Guardrails","text":"<p>A key use case for linkml-term-validator is preventing AI systems from hallucinating ontology identifiers.</p>"},{"location":"anti-hallucination/#the-problem","title":"The Problem","text":"<p>Language models frequently hallucinate identifiers like gene IDs, ontology terms, and other structured references. These fake identifiers often appear structurally correct (e.g., <code>GO:9999999</code>, <code>CHEBI:88888</code>) but don't actually exist in the source ontologies.</p> <p>This creates serious data quality issues:</p> <ul> <li>Invalid references that break data integration</li> <li>Nonsense annotations that corrupt curated datasets</li> <li>False confidence in AI-generated content</li> </ul>"},{"location":"anti-hallucination/#the-solution-dual-validation","title":"The Solution: Dual Validation","text":"<p>A robust guardrail requires dual validation\u2014forcing the AI to provide both the identifier AND its canonical label, then validating that they match:</p> <p>Instead of accepting:</p> <pre><code>term: GO:0005515  # Single piece of information - easy to hallucinate\n</code></pre> <p>Require and validate:</p> <pre><code>term:\n  id: GO:0005515\n  label: protein binding  # Must match canonical label in ontology\n</code></pre> <p>This dramatically reduces hallucinations because the AI must get two interdependent facts correct simultaneously, which is significantly harder to fake convincingly than inventing a single plausible-looking identifier.</p>"},{"location":"anti-hallucination/#implementation-pattern","title":"Implementation Pattern","text":""},{"location":"anti-hallucination/#1-define-schemas-with-binding-constraints","title":"1. Define Schemas with Binding Constraints","text":"<pre><code>prefixes:\n  rdfs: http://www.w3.org/2000/01/rdf-schema#\n\nclasses:\n  GeneAnnotation:\n    slots:\n      - gene\n      - go_term\n    slot_usage:\n      go_term:\n        range: GOTerm\n        bindings:\n          - binds_value_of: id\n            range: BiologicalProcessEnum\n\n  GOTerm:\n    slots:\n      - id        # AI must provide both\n      - label     # fields correctly\n    slot_usage:\n      label:\n        implements:\n          - rdfs:label  # Explicit: this field should match ontology label\n\nenums:\n  BiologicalProcessEnum:\n    reachable_from:\n      source_ontology: sqlite:obo:go\n      source_nodes:\n        - GO:0008150  # biological_process\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre> <p>The <code>implements: [rdfs:label]</code> declaration explicitly tells the validator that this field should be validated against the ontology's <code>rdfs:label</code>. This is more robust than relying on naming conventions.</p>"},{"location":"anti-hallucination/#2-validate-ai-generated-outputs-before-committing","title":"2. Validate AI-Generated Outputs Before Committing","text":"<pre><code>from linkml.validator import Validator\nfrom linkml_term_validator.plugins import BindingValidationPlugin\n\n# Create validator with label checking enabled\nplugin = BindingValidationPlugin(\n    oak_adapter_string=\"sqlite:obo:\",\n    validate_labels=True\n)\nvalidator = Validator(schema=\"schema.yaml\", validation_plugins=[plugin])\n\n# Validate AI-generated data\nreport = validator.validate_source(loader, target_class=\"GeneAnnotation\")\n\nif len(report.results) &gt; 0:\n    # Reject hallucinated terms, prompt AI to regenerate\n    for result in report.results:\n        print(f\"ERROR: {result.message}\")\n    raise ValueError(\"Invalid ontology terms detected\")\n</code></pre>"},{"location":"anti-hallucination/#3-use-validation-during-generation","title":"3. Use Validation During Generation","text":"<p>The most effective approach embeds validation during AI generation rather than treating it as a filtering step afterward. This transforms hallucination resistance from a detection problem into a generation constraint.</p> <p>Pattern:</p> <ol> <li>AI generates structured output with id+label pairs</li> <li>Validate immediately with <code>BindingValidationPlugin(validate_labels=True)</code></li> <li>If validation fails, provide error messages back to AI with retry opportunity</li> <li>Only accept outputs that pass validation</li> </ol>"},{"location":"anti-hallucination/#what-gets-validated","title":"What Gets Validated","text":"<p>The <code>BindingValidationPlugin</code> with <code>validate_labels=True</code> checks:</p> <ol> <li>ID exists in ontology: The identifier (e.g., <code>GO:0005515</code>) is a real term</li> <li>ID matches constraint: The term satisfies the binding's range constraint (e.g., is a biological process)</li> <li>Label matches ontology: The provided label matches the canonical label from the ontology</li> </ol> <p>All three checks must pass.</p>"},{"location":"anti-hallucination/#real-world-benefits","title":"Real-World Benefits","text":"<ul> <li>Prevents fake identifiers from entering curated datasets</li> <li>Catches label mismatches where AI uses real IDs but wrong labels</li> <li>Validates dynamic constraints (e.g., only disease terms, only neuron types)</li> <li>Enables reliable automation of curation tasks traditionally requiring human experts</li> </ul>"},{"location":"anti-hallucination/#example-invalid-ai-output","title":"Example: Invalid AI Output","text":"<pre><code>annotations:\n  - gene: BRCA1\n    go_term:\n      id: GO:0005515\n      label: DNA binding  # \u274c WRONG - actual label is \"protein binding\"\n</code></pre> <p>Validation result:</p> <pre><code>ERROR: Label mismatch for GO:0005515\n  Expected: protein binding\n  Found: DNA binding\n</code></pre>"},{"location":"anti-hallucination/#example-hallucinated-id","title":"Example: Hallucinated ID","text":"<pre><code>annotations:\n  - gene: BRCA1\n    go_term:\n      id: GO:9999999  # \u274c Doesn't exist\n      label: cell stuff\n</code></pre> <p>Validation result:</p> <pre><code>ERROR: GO:9999999 not found in Gene Ontology\n</code></pre>"},{"location":"anti-hallucination/#cli-usage","title":"CLI Usage","text":"<pre><code># Validate with label checking enabled\nlinkml-term-validator validate-data data.yaml \\\n  --schema schema.yaml \\\n  --labels  # Enable label validation\n</code></pre>"},{"location":"anti-hallucination/#best-practices","title":"Best Practices","text":"<ol> <li>Always use dual validation (id + label) for AI-generated ontology references</li> <li>Provide clear error messages back to the AI when validation fails</li> <li>Use dynamic enums to constrain valid terms (e.g., only disease terms)</li> <li>Cache ontology labels for fast validation during generation</li> <li>Validate early and often - don't wait until after bulk generation</li> </ol>"},{"location":"anti-hallucination/#learn-more","title":"Learn More","text":"<p>For detailed patterns and best practices on making ontology IDs hallucination-resistant in AI workflows, see:</p> <ul> <li>Make IDs Hallucination Resistant - Comprehensive guide from the AI for Curation project</li> <li>Python API Tutorial - Interactive notebook demonstrating validation workflows</li> <li>Advanced Usage - CLI patterns for binding validation</li> </ul>"},{"location":"anti-hallucination/#see-also","title":"See Also","text":"<ul> <li>Binding Validation - Technical details</li> <li>Python API - Programmatic usage</li> </ul>"},{"location":"binding-validation/","title":"Binding Validation Reference","text":"<p>This reference covers validation of binding constraints on nested objects\u2014ensuring that fields within complex objects satisfy enum range constraints, with optional label validation.</p>"},{"location":"binding-validation/#overview","title":"Overview","text":"<p>Binding validation uses the BindingValidationPlugin to validate that:</p> <ol> <li>Fields within nested objects satisfy their binding range constraints</li> <li>(Optionally) Labels match the ontology's canonical labels</li> </ol> <p>Bindings are essential when your data uses complex objects (like <code>OntologyTerm</code> with <code>id</code> and <code>label</code>) rather than simple CURIE strings.</p>"},{"location":"binding-validation/#cli-usage","title":"CLI Usage","text":"<pre><code># Basic binding validation\nlinkml-term-validator validate-data data.yaml --schema schema.yaml\n\n# With label validation (anti-hallucination)\nlinkml-term-validator validate-data data.yaml -s schema.yaml --labels\n\n# With target class\nlinkml-term-validator validate-data data.yaml -s schema.yaml -t GeneAnnotation --labels\n\n# With custom OAK configuration\nlinkml-term-validator validate-data data.yaml -s schema.yaml --oak-config oak_config.yaml --labels\n</code></pre>"},{"location":"binding-validation/#cli-options","title":"CLI Options","text":"Option Description <code>--schema</code>, <code>-s</code> Path to LinkML schema (required) <code>--target-class</code>, <code>-t</code> Target class for validation <code>--labels</code> Also validate labels against ontology <code>--lenient</code> Don't fail when term IDs are not found in ontology <code>--oak-adapter</code> OAK adapter string (default: <code>sqlite:obo:</code>) <code>--oak-config</code> Path to OAK configuration file <code>--cache-dir</code> Directory for cache files (default: <code>cache</code>) <code>--verbose</code> / <code>-v</code> Enable verbose output"},{"location":"binding-validation/#strict-mode-default","title":"Strict Mode (Default)","text":"<p>By default, the validator operates in strict mode, which fails validation when:</p> <ol> <li>A term ID is not found in a configured ontology</li> <li>A term ID is outside the dynamic enum closure</li> </ol> <p>This catches fabricated/hallucinated term IDs that don't actually exist.</p> <p>Use <code>--lenient</code> to disable strict existence checking (closure validation still applies).</p>"},{"location":"binding-validation/#binding-syntax","title":"Binding Syntax","text":""},{"location":"binding-validation/#basic-binding","title":"Basic Binding","text":"<pre><code>classes:\n  GeneAnnotation:\n    attributes:\n      go_term:\n        range: OntologyTerm\n        bindings:\n          - binds_value_of: id              # Field to constrain\n            range: BiologicalProcessEnum    # Enum defining valid values\n</code></pre>"},{"location":"binding-validation/#binding-properties","title":"Binding Properties","text":"Property Required Description <code>binds_value_of</code> Yes The field path within the nested object <code>range</code> Yes The enum (static or dynamic) defining allowed values <code>obligation_level</code> No <code>REQUIRED</code>, <code>RECOMMENDED</code>, or <code>OPTIONAL</code>"},{"location":"binding-validation/#obligation-levels","title":"Obligation Levels","text":"Level Description Validation Behavior <code>REQUIRED</code> Must satisfy constraint ERROR on violation <code>RECOMMENDED</code> Should satisfy constraint WARN on violation <code>OPTIONAL</code> May satisfy constraint No validation <pre><code>bindings:\n  - binds_value_of: id\n    range: BiologicalProcessEnum\n    obligation_level: REQUIRED     # Default if not specified\n</code></pre>"},{"location":"binding-validation/#label-field-detection","title":"Label Field Detection","text":"<p>The plugin needs to know which field contains the label to validate. There are three mechanisms:</p>"},{"location":"binding-validation/#1-using-implements-recommended","title":"1. Using <code>implements</code> (Recommended)","text":"<p>Use <code>implements</code> to declare the label field:</p> <pre><code>classes:\n  OntologyTerm:\n    attributes:\n      id:\n        identifier: true\n      name:\n        implements:\n          - rdfs:label              # Declares this is the label field\n</code></pre>"},{"location":"binding-validation/#2-using-slot_uri","title":"2. Using <code>slot_uri</code>","text":"<p>Alternatively, use <code>slot_uri</code> to declare the field's semantic meaning:</p> <pre><code>classes:\n  OntologyTerm:\n    attributes:\n      id:\n        identifier: true\n      label:\n        slot_uri: rdfs:label        # Also declares this is the label field\n</code></pre>"},{"location":"binding-validation/#supported-label-properties","title":"Supported Label Properties","text":"Property Description <code>rdfs:label</code> Standard RDF label <code>skos:prefLabel</code> SKOS preferred label <code>schema:name</code> Schema.org name <code>oboInOwl:hasExactSynonym</code> OBO exact synonym"},{"location":"binding-validation/#3-convention-based-fallback","title":"3. Convention-Based (Fallback)","text":"<p>If no <code>implements</code> or <code>slot_uri</code> is declared, the plugin falls back to looking for a field named <code>label</code>:</p> <pre><code>classes:\n  OntologyTerm:\n    attributes:\n      id:\n        identifier: true\n      label:                        # Detected by convention\n        range: string\n</code></pre>"},{"location":"binding-validation/#nested-structure-validation","title":"Nested Structure Validation","text":"<p>The plugin recursively validates all nesting levels, not just the top-level class. This is critical for real-world schemas.</p>"},{"location":"binding-validation/#example-deeply-nested-structure","title":"Example: Deeply Nested Structure","text":"<p>Schema:</p> <pre><code>classes:\n  Study:\n    attributes:\n      samples:\n        range: Sample\n        multivalued: true\n        inlined_as_list: true\n\n  Sample:\n    attributes:\n      annotations:\n        range: Annotation\n        multivalued: true\n        inlined_as_list: true\n\n  Annotation:\n    attributes:\n      term:\n        range: OntologyTerm\n        bindings:                   # \u2190 Binding at nested level\n          - binds_value_of: id\n            range: AnnotationTermEnum\n</code></pre> <p>Data:</p> <pre><code>samples:\n  - annotations:\n      - term:\n          id: GO:0007049           # \u2190 Validated!\n          label: cell cycle\n</code></pre> <p>Error message with path:</p> <pre><code>ERROR: Value 'GO:9999999' not in enum 'AnnotationTermEnum'\n  path: samples[0].annotations[1].term\n  slot: term\n  field: id\n</code></pre>"},{"location":"binding-validation/#multivalued-slots","title":"Multivalued Slots","text":"<p>Both the parent slot and the nested objects can be multivalued:</p> <pre><code>classes:\n  Disease:\n    attributes:\n      affected_tissues:\n        range: TissueDescriptor\n        multivalued: true              # Multiple tissues\n        inlined_as_list: true\n        bindings:\n          - binds_value_of: id\n            range: AnatomyEnum\n</code></pre> <p>Each item in the list is validated independently:</p> <pre><code>affected_tissues:\n  - id: UBERON:0000955              # brain - validated\n    label: brain\n  - id: UBERON:0000948              # heart - validated\n    label: heart\n  - id: PIZZA:MARGHERITA           # INVALID - not anatomy\n    label: delicious\n</code></pre>"},{"location":"binding-validation/#complete-example","title":"Complete Example","text":""},{"location":"binding-validation/#schema","title":"Schema","text":"<pre><code>id: https://example.org/annotation-schema\nname: annotation-schema\nprefixes:\n  GO: http://purl.obolibrary.org/obo/GO_\n  rdfs: http://www.w3.org/2000/01/rdf-schema#\n  linkml: https://w3id.org/linkml/\n\nclasses:\n  GeneAnnotation:\n    attributes:\n      gene_id:\n        range: string\n        identifier: true\n      process:\n        range: GOTerm\n        bindings:\n          - binds_value_of: id\n            range: BiologicalProcessEnum\n      location:\n        range: GOTerm\n        bindings:\n          - binds_value_of: id\n            range: CellularComponentEnum\n\n  GOTerm:\n    attributes:\n      id:\n        identifier: true\n      label:\n        implements:\n          - rdfs:label\n\nenums:\n  BiologicalProcessEnum:\n    reachable_from:\n      source_ontology: sqlite:obo:go\n      source_nodes:\n        - GO:0008150              # biological_process\n      relationship_types:\n        - rdfs:subClassOf\n\n  CellularComponentEnum:\n    reachable_from:\n      source_ontology: sqlite:obo:go\n      source_nodes:\n        - GO:0005575              # cellular_component\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre>"},{"location":"binding-validation/#valid-data","title":"Valid Data","text":"<pre><code>gene_id: BRCA1\nprocess:\n  id: GO:0007049                  # cell cycle - is a biological process\n  label: cell cycle\nlocation:\n  id: GO:0005634                  # nucleus - is a cellular component\n  label: nucleus\n</code></pre>"},{"location":"binding-validation/#invalid-data","title":"Invalid Data","text":"<pre><code>gene_id: BRCA1\nprocess:\n  id: GO:0005634                  # nucleus - WRONG! Not a process\n  label: nucleus\nlocation:\n  id: GO:0007049                  # cell cycle - WRONG! Not a component\n  label: cell cycle\n</code></pre>"},{"location":"binding-validation/#validation-commands","title":"Validation Commands","text":"<pre><code># Binding validation only\nlinkml-term-validator validate-data annotations.yaml -s schema.yaml -t GeneAnnotation\n# Output: 2 binding errors (wrong enum values)\n\n# With label validation\nlinkml-term-validator validate-data annotations.yaml -s schema.yaml -t GeneAnnotation --labels\n# Also validates that labels match ontology\n</code></pre>"},{"location":"binding-validation/#python-api","title":"Python API","text":"<pre><code>from linkml.validator import Validator\nfrom linkml_runtime.loaders import yaml_loader\nfrom linkml_term_validator.plugins import BindingValidationPlugin\n\n# Create plugin with label validation\nplugin = BindingValidationPlugin(\n    oak_adapter_string=\"sqlite:obo:\",\n    validate_labels=True,          # Enable label checking\n    cache_labels=True,\n    cache_dir=\"cache\",\n)\n\n# Create validator\nvalidator = Validator(\n    schema=\"schema.yaml\",\n    validation_plugins=[plugin]\n)\n\n# Validate\nloader = yaml_loader.YamlLoader()\nreport = validator.validate_source(\n    loader,\n    \"data.yaml\",\n    target_class=\"GeneAnnotation\"\n)\n\n# Check results\nfor result in report.results:\n    print(f\"{result.severity.name}: {result.message}\")\n</code></pre>"},{"location":"binding-validation/#plugin-parameters","title":"Plugin Parameters","text":"Parameter Type Default Description <code>oak_adapter_string</code> <code>str</code> <code>\"sqlite:obo:\"</code> Default OAK adapter <code>oak_config_path</code> <code>str \\| None</code> <code>None</code> Path to OAK config file <code>validate_labels</code> <code>bool</code> <code>False</code> Also validate labels <code>strict</code> <code>bool</code> <code>True</code> Fail when term IDs not found in configured ontologies <code>cache_labels</code> <code>bool</code> <code>True</code> Enable file-based caching <code>cache_dir</code> <code>str</code> <code>\"cache\"</code> Cache directory"},{"location":"binding-validation/#error-messages","title":"Error Messages","text":""},{"location":"binding-validation/#binding-violation-static-enum","title":"Binding Violation (Static Enum)","text":"<pre><code>ERROR: Value 'GO:0005634' not in enum 'BiologicalProcessEnum'\n  path: process\n  slot: process\n  field: id\n</code></pre>"},{"location":"binding-validation/#binding-violation-dynamic-enum-closure","title":"Binding Violation (Dynamic Enum Closure)","text":"<p>When the term exists but is outside the ontology closure:</p> <pre><code>ERROR: Value 'GO:0005634' not in dynamic enum (expanded from ontology) 'BiologicalProcessEnum'\n  path: process\n  slot: process\n  field: id\n  allowed_values: 29688 terms\n</code></pre>"},{"location":"binding-validation/#term-not-found-strict-mode","title":"Term Not Found (Strict Mode)","text":"<p>When a term ID doesn't exist in a configured ontology:</p> <pre><code>ERROR: Term 'GO:9999999' not found in ontology\n  path: process\n  slot: process\n  field: id\n  prefix: GO (configured in oak_config)\n</code></pre>"},{"location":"binding-validation/#label-mismatch-with-labels","title":"Label Mismatch (with <code>--labels</code>)","text":"<pre><code>ERROR: Label mismatch for GO:0007049\n  Expected (from data): \"Cell Cycle\"\n  Found (from ontology): \"cell cycle\"\n  path: process.label\n</code></pre>"},{"location":"binding-validation/#nested-path-example","title":"Nested Path Example","text":"<pre><code>ERROR: Value 'GO:9999999' not in enum 'CellularComponentEnum'\n  path: samples[0].annotations[2].term\n  slot: term\n  field: id\n</code></pre>"},{"location":"binding-validation/#anti-hallucination-use-case","title":"Anti-Hallucination Use Case","text":"<p>When validating AI-generated data, enable label validation to catch hallucinated terms:</p> <pre><code># AI might generate plausible-looking but wrong data:\n# {\n#   \"id\": \"GO:0007049\",\n#   \"label\": \"DNA repair\"        # WRONG! Actual label is \"cell cycle\"\n# }\n\nplugin = BindingValidationPlugin(validate_labels=True)\n# This will catch the mismatch!\n</code></pre> <p>See Anti-Hallucination Guardrails for more details.</p>"},{"location":"binding-validation/#combining-with-dynamicenumplugin","title":"Combining with DynamicEnumPlugin","text":"<p>For comprehensive validation, use both plugins:</p> <pre><code>from linkml.validator import Validator\nfrom linkml_term_validator.plugins import (\n    DynamicEnumPlugin,\n    BindingValidationPlugin,\n)\n\nplugins = [\n    DynamicEnumPlugin(),                      # Direct enum slots\n    BindingValidationPlugin(validate_labels=True),  # Nested object bindings\n]\n\nvalidator = Validator(schema=\"schema.yaml\", validation_plugins=plugins)\n</code></pre> <ul> <li>DynamicEnumPlugin: Validates slots that directly use dynamic enum ranges</li> <li>BindingValidationPlugin: Validates fields within nested objects via bindings</li> </ul>"},{"location":"binding-validation/#common-patterns","title":"Common Patterns","text":""},{"location":"binding-validation/#reusable-term-class","title":"Reusable Term Class","text":"<pre><code>classes:\n  Term:\n    attributes:\n      id:\n        identifier: true\n      label:\n        implements:\n          - rdfs:label\n\n  GeneAnnotation:\n    attributes:\n      process:\n        range: Term\n        bindings:\n          - binds_value_of: id\n            range: ProcessEnum\n      component:\n        range: Term\n        bindings:\n          - binds_value_of: id\n            range: ComponentEnum\n</code></pre>"},{"location":"binding-validation/#slot-usage-override","title":"Slot Usage Override","text":"<p>Override bindings in subclasses:</p> <pre><code>classes:\n  Annotation:\n    attributes:\n      term:\n        range: Term\n\n  GeneAnnotation:\n    is_a: Annotation\n    slot_usage:\n      term:\n        bindings:\n          - binds_value_of: id\n            range: GOTermEnum\n</code></pre>"},{"location":"binding-validation/#see-also","title":"See Also","text":"<ul> <li>Bindings Explained - Conceptual overview</li> <li>Data Validation - Dynamic enum validation</li> <li>Anti-Hallucination Guardrails - AI validation</li> <li>Plugin Reference - Complete API reference</li> </ul>"},{"location":"bindings-explained/","title":"Bindings: Constraining Complex Objects","text":"<p>Bindings are a powerful LinkML feature that constrain fields within complex (nested) objects to specific value sets. This page explains the concept, draws parallels with FHIR terminology bindings, and shows how linkml-term-validator implements binding validation.</p>"},{"location":"bindings-explained/#the-problem-validating-nested-structures","title":"The Problem: Validating Nested Structures","text":"<p>Consider a schema for gene annotations:</p> <pre><code>classes:\n  GeneAnnotation:\n    attributes:\n      gene:\n        range: string\n      ontology_term:\n        range: OntologyTerm\n        inlined: true\n\n  OntologyTerm:\n    attributes:\n      id:\n        range: string\n      label:\n        range: string\n</code></pre> <p>This allows any <code>OntologyTerm</code>:</p> <pre><code>gene: BRCA1\nontology_term:\n  id: GO:0007049       # Valid GO term\n  label: cell cycle\n\ngene: TP53\nontology_term:\n  id: PIZZA:MARGHERITA  # Nonsense!\n  label: delicious\n</code></pre> <p>Problem: The <code>OntologyTerm</code> class is generic\u2014it accepts any CURIE. But for gene annotations, we want to restrict terms to the Gene Ontology.</p>"},{"location":"bindings-explained/#the-solution-bindings","title":"The Solution: Bindings","text":"<p>Bindings constrain a specific field within a complex object to an enum range:</p> <pre><code>classes:\n  GeneAnnotation:\n    attributes:\n      gene:\n        range: string\n      ontology_term:\n        range: OntologyTerm\n        inlined: true\n        bindings:\n          - binds_value_of: id\n            range: GOBiologicalProcessEnum\n\nenums:\n  GOBiologicalProcessEnum:\n    reachable_from:\n      source_ontology: obo:go\n      source_nodes:\n        - GO:0008150  # biological_process\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre> <p>Now the <code>id</code> field within <code>ontology_term</code> must be a GO biological process term.</p>"},{"location":"bindings-explained/#anatomy-of-a-binding","title":"Anatomy of a Binding","text":"<pre><code>bindings:\n  - binds_value_of: id              # Which field to constrain\n    range: GOBiologicalProcessEnum  # The enum defining allowed values\n    obligation_level: RECOMMENDED   # How strictly to enforce\n</code></pre>"},{"location":"bindings-explained/#binding-properties","title":"Binding Properties","text":"Property Description <code>binds_value_of</code> The field path within the nested object to validate <code>range</code> The enum (static or dynamic) defining allowed values <code>obligation_level</code> <code>REQUIRED</code>, <code>RECOMMENDED</code>, or <code>OPTIONAL</code>"},{"location":"bindings-explained/#comparison-with-fhir-terminology-bindings","title":"Comparison with FHIR Terminology Bindings","text":"<p>LinkML bindings are conceptually similar to FHIR terminology bindings, which connect data elements to controlled vocabularies.</p>"},{"location":"bindings-explained/#fhir-binding-strengths","title":"FHIR Binding Strengths","text":"<p>FHIR defines five binding strengths:</p> Strength Description LinkML Equivalent Required Must use a code from the value set <code>obligation_level: REQUIRED</code> Extensible Should use value set codes if applicable <code>obligation_level: RECOMMENDED</code> Preferred Encouraged but not required <code>obligation_level: RECOMMENDED</code> Example Illustrative only No validation"},{"location":"bindings-explained/#fhir-codeableconcept","title":"FHIR CodeableConcept","text":"<p>In FHIR, a <code>CodeableConcept</code> is similar to LinkML's pattern of an object with <code>id</code> and <code>label</code>:</p> <pre><code>{\n  \"coding\": [\n    {\n      \"system\": \"http://snomed.info/sct\",\n      \"code\": \"386661006\",\n      \"display\": \"Fever\"\n    }\n  ],\n  \"text\": \"Fever\"\n}\n</code></pre> <p>FHIR bindings constrain which codes are valid for a CodeableConcept in a given context\u2014exactly what LinkML bindings do.</p>"},{"location":"bindings-explained/#key-insight-from-fhir","title":"Key Insight from FHIR","text":"<p>FHIR's documentation emphasizes: \"A binding strength of 'required' or 'extensible' does not indicate that ALL of the codes in the bound value set will be supported. It constrains the set of codes that are allowed to be shared.\"</p> <p>This is equally true in LinkML: bindings constrain what values are valid, not what values implementations must support.</p>"},{"location":"bindings-explained/#use-cases-for-bindings","title":"Use Cases for Bindings","text":""},{"location":"bindings-explained/#1-descriptor-pattern","title":"1. Descriptor Pattern","text":"<p>Wrap ontology terms in descriptive objects:</p> <pre><code>classes:\n  DiseaseDescriptor:\n    attributes:\n      preferred_term:\n        range: string\n      synonyms:\n        range: string\n        multivalued: true\n      term:\n        range: OntologyTerm\n        bindings:\n          - binds_value_of: id\n            range: DiseaseEnum\n</code></pre>"},{"location":"bindings-explained/#2-multi-context-annotations","title":"2. Multi-Context Annotations","text":"<p>Same class, different bindings in different contexts:</p> <pre><code>classes:\n  Sample:\n    attributes:\n      tissue:\n        range: OntologyTerm\n        bindings:\n          - binds_value_of: id\n            range: AnatomyEnum\n\n      cell_type:\n        range: OntologyTerm\n        bindings:\n          - binds_value_of: id\n            range: CellTypeEnum\n</code></pre>"},{"location":"bindings-explained/#3-deeply-nested-structures","title":"3. Deeply Nested Structures","text":"<p>Bindings validate at all nesting levels:</p> <pre><code>classes:\n  Study:\n    attributes:\n      samples:\n        range: Sample\n        multivalued: true\n\n  Sample:\n    attributes:\n      annotations:\n        range: Annotation\n        multivalued: true\n\n  Annotation:\n    attributes:\n      term:\n        range: OntologyTerm\n        bindings:\n          - binds_value_of: id\n            range: AnnotationTermEnum\n</code></pre>"},{"location":"bindings-explained/#label-validation","title":"Label Validation","text":"<p>Beyond validating the <code>id</code>, you may want to verify the <code>label</code> matches the ontology:</p> <pre><code>classes:\n  OntologyTerm:\n    attributes:\n      id:\n        identifier: true\n      label:\n        implements:\n          - rdfs:label  # Declares this field holds the rdfs:label\n</code></pre> <p>With <code>--labels</code> flag, the validator checks that provided labels match the ontology's canonical labels.</p>"},{"location":"bindings-explained/#anti-hallucination-benefits","title":"Anti-Hallucination Benefits","text":"<p>Bindings are particularly valuable for validating AI-generated content. By requiring both:</p> <ol> <li>A valid ontology term ID</li> <li>A matching label</li> </ol> <p>...you ensure the AI correctly retrieved real ontology data rather than hallucinating plausible-looking identifiers. See Anti-Hallucination Guardrails.</p>"},{"location":"bindings-explained/#validation-with-linkml-term-validator","title":"Validation with linkml-term-validator","text":""},{"location":"bindings-explained/#cli","title":"CLI","text":"<pre><code># Validate bindings (and dynamic enums)\nlinkml-term-validator validate-data data.yaml -s schema.yaml -t ClassName\n\n# Also validate labels match ontology\nlinkml-term-validator validate-data data.yaml -s schema.yaml -t ClassName --labels\n</code></pre>"},{"location":"bindings-explained/#python-api","title":"Python API","text":"<pre><code>from linkml_term_validator.plugins import BindingValidationPlugin\n\nplugin = BindingValidationPlugin(\n    validate_labels=True,\n    oak_adapter_string=\"sqlite:obo:\"\n)\n</code></pre>"},{"location":"bindings-explained/#common-patterns","title":"Common Patterns","text":""},{"location":"bindings-explained/#reusable-term-classes","title":"Reusable Term Classes","text":"<p>Define a generic term class, constrain via bindings:</p> <pre><code>classes:\n  Term:\n    attributes:\n      id:\n        identifier: true\n      label:\n        implements:\n          - rdfs:label\n\n  GeneAnnotation:\n    attributes:\n      process:\n        range: Term\n        bindings:\n          - binds_value_of: id\n            range: BiologicalProcessEnum\n      location:\n        range: Term\n        bindings:\n          - binds_value_of: id\n            range: CellularComponentEnum\n</code></pre>"},{"location":"bindings-explained/#slot-usage-for-context-specific-bindings","title":"Slot Usage for Context-Specific Bindings","text":"<p>Override bindings in subclasses:</p> <pre><code>classes:\n  Annotation:\n    attributes:\n      term:\n        range: Term\n\n  GeneAnnotation:\n    is_a: Annotation\n    slot_usage:\n      term:\n        bindings:\n          - binds_value_of: id\n            range: GOTermEnum\n</code></pre>"},{"location":"bindings-explained/#see-also","title":"See Also","text":"<ul> <li>Ontologies in LinkML - Background on ontologies</li> <li>Enumerations - Static and dynamic enums</li> <li>Binding Validation Reference - Detailed validation behavior</li> <li>Anti-Hallucination Guardrails - Using bindings for AI validation</li> </ul>"},{"location":"bindings-explained/#external-resources","title":"External Resources","text":"<ul> <li>LinkML Bindings Documentation</li> <li>FHIR Terminology Bindings</li> <li>FHIR Binding Strength</li> </ul>"},{"location":"caching/","title":"Caching","text":"<p>The validator uses multi-level caching to speed up repeated validations and avoid redundant ontology queries.</p>"},{"location":"caching/#cache-types","title":"Cache Types","text":"<p>There are two types of caches:</p> <ol> <li>Label cache - Maps CURIEs to their canonical labels (for label validation)</li> <li>Enum cache - Stores expanded dynamic enum values (for closure validation)</li> </ol>"},{"location":"caching/#in-memory-cache","title":"In-Memory Cache","text":"<p>During a single validation run, ontology labels and enum values are cached in memory. If multiple fields reference the same term or enum, lookups are only done once.</p> <p>This cache exists only for the duration of the validation process and is discarded afterward.</p>"},{"location":"caching/#label-cache-file-based","title":"Label Cache (File-Based)","text":"<p>Labels are persisted to CSV files in the cache directory (default: <code>./cache</code>):</p> <pre><code>cache/\n\u251c\u2500\u2500 go/\n\u2502   \u2514\u2500\u2500 terms.csv      # GO term labels\n\u251c\u2500\u2500 chebi/\n\u2502   \u2514\u2500\u2500 terms.csv      # CHEBI term labels\n\u2514\u2500\u2500 uberon/\n    \u2514\u2500\u2500 terms.csv      # UBERON term labels\n</code></pre>"},{"location":"caching/#label-cache-format","title":"Label Cache Format","text":"<pre><code>curie,label,retrieved_at\nGO:0008150,biological_process,2025-11-15T10:30:00\nGO:0007049,cell cycle,2025-11-15T10:30:01\n</code></pre>"},{"location":"caching/#enum-cache-dynamic-enums","title":"Enum Cache (Dynamic Enums)","text":"<p>Dynamic enums (those using <code>reachable_from</code>, <code>matches</code>, or <code>concepts</code>) can be cached to avoid expensive ontology traversals. Enum caches are stored in:</p> <pre><code>cache/\n\u2514\u2500\u2500 enums/\n    \u251c\u2500\u2500 biologicalprocessenum_abc123.csv\n    \u251c\u2500\u2500 cellularcomponentenum_def456.csv\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"caching/#enum-cache-format","title":"Enum Cache Format","text":"<pre><code>curie\nGO:0008150\nGO:0007049\nGO:0006260\n</code></pre> <p>The cache filename includes a hash of the enum definition, so changes to source nodes or relationship types automatically invalidate the cache.</p>"},{"location":"caching/#enum-caching-strategies","title":"Enum Caching Strategies","text":"<p>The validator supports two strategies for caching dynamic enum values:</p>"},{"location":"caching/#progressive-caching-default","title":"Progressive Caching (Default)","text":"<p>Progressive caching validates terms lazily:</p> <ol> <li>Check in-memory cache</li> <li>Check file cache</li> <li>Query ontology directly (is this term a descendant of the source nodes?)</li> <li>If valid, add to cache for future lookups</li> </ol> <p>Benefits: - Scales well for large ontologies (SNOMED with 100k+ terms) - Cache grows organically with actual usage - Faster startup (no upfront expansion) - Supports \"lazy list\" style enums (e.g., any valid chemical SMILES)</p> <p>Trade-offs: - First validation of each term requires ontology query - Cache is append-only (may contain terms no longer in use)</p>"},{"location":"caching/#greedy-caching","title":"Greedy Caching","text":"<p>Greedy caching expands the entire enum upfront:</p> <ol> <li>On first access, query ontology for ALL descendants</li> <li>Cache the complete set</li> <li>Subsequent lookups are simple set membership checks</li> </ol> <p>Benefits: - Deterministic - same results every time - No per-term ontology queries after initial expansion - Good for smaller, frequently-validated enums</p> <p>Trade-offs: - Slow startup for large ontologies - Memory-intensive for large closures - May cache terms never actually used</p>"},{"location":"caching/#cache-behavior","title":"Cache Behavior","text":"<ul> <li>First run: Queries ontology databases, saves results to cache</li> <li>Subsequent runs: Loads from cache files (very fast, no network/database access)</li> <li>Cache location: Configurable via <code>--cache-dir</code> flag</li> <li>Disable caching: Use <code>--no-cache</code> flag</li> </ul>"},{"location":"caching/#configuration","title":"Configuration","text":""},{"location":"caching/#cli","title":"CLI","text":"<pre><code># Use custom cache directory\nlinkml-term-validator validate-schema --cache-dir /path/to/cache schema.yaml\n\n# Disable caching\nlinkml-term-validator validate-schema --no-cache schema.yaml\n\n# Use greedy caching strategy (expand all upfront)\nlinkml-term-validator validate-data data.yaml -s schema.yaml --cache-strategy greedy\n\n# Use progressive caching strategy (default, lazy validation)\nlinkml-term-validator validate-data data.yaml -s schema.yaml --cache-strategy progressive\n</code></pre>"},{"location":"caching/#python-api","title":"Python API","text":"<pre><code>from linkml_term_validator.plugins import DynamicEnumPlugin, BindingValidationPlugin\nfrom linkml_term_validator.models import CacheStrategy\n\n# Progressive caching (default) - recommended for large ontologies\nplugin = DynamicEnumPlugin(\n    cache_dir=\"/path/to/cache\",\n    cache_labels=True,\n    cache_strategy=CacheStrategy.PROGRESSIVE,\n)\n\n# Greedy caching - expand all upfront\nplugin = BindingValidationPlugin(\n    cache_dir=\"/path/to/cache\",\n    cache_labels=True,\n    cache_strategy=CacheStrategy.GREEDY,\n)\n</code></pre>"},{"location":"caching/#yaml-configuration-oak_configyaml","title":"YAML Configuration (oak_config.yaml)","text":"<pre><code># Set cache strategy globally\ncache_strategy: progressive  # or \"greedy\"\n\n# Configure ontology adapters\nontology_adapters:\n  GO: sqlite:obo:go\n  HP: sqlite:obo:hp\n  CL: sqlite:obo:cl\n</code></pre>"},{"location":"caching/#linkml-validate-configuration","title":"linkml-validate Configuration","text":"<pre><code>plugins:\n  \"linkml_term_validator.plugins.DynamicEnumPlugin\":\n    oak_adapter_string: \"sqlite:obo:\"\n    cache_labels: true\n    cache_dir: cache\n    cache_strategy: progressive  # or \"greedy\"\n</code></pre>"},{"location":"caching/#choosing-a-cache-strategy","title":"Choosing a Cache Strategy","text":"Use Case Recommended Strategy Large ontologies (SNOMED, NCBI Taxonomy) Progressive Small, stable enums (&lt; 1000 terms) Greedy First-time validation of new dataset Progressive Repeated validation of same dataset Either (after initial cache) CI/CD pipelines Greedy (deterministic) Interactive development Progressive (faster startup) <p>Rule of thumb: Start with progressive (the default). Switch to greedy only if you need deterministic behavior or are validating the same small dataset repeatedly.</p>"},{"location":"caching/#when-to-clear-cache","title":"When to Clear Cache","text":"<p>You might want to clear the cache if:</p> <ul> <li>Ontology databases have been updated and you need the latest labels</li> <li>You suspect stale or incorrect labels in cached data</li> <li>You're testing validation behavior and want to force fresh lookups</li> </ul> <pre><code># Clear cache for specific ontology\nrm -rf cache/go/\n\n# Clear entire cache\nrm -rf cache/\n</code></pre>"},{"location":"caching/#performance-benefits","title":"Performance Benefits","text":"<p>Caching provides significant performance improvements:</p> <ul> <li>First validation: May take several seconds per ontology (database queries)</li> <li>Cached validations: Typically &lt; 100ms (CSV file reads)</li> <li>No network dependency: Cached validations work offline</li> </ul>"},{"location":"caching/#reproducibility-versioning-ontology-snapshots","title":"Reproducibility: Versioning Ontology Snapshots","text":"<p>A key benefit of file-based caching is reproducible validation. By committing the cache directory alongside your schema, you create a versioned snapshot of the ontology state.</p>"},{"location":"caching/#why-this-matters","title":"Why This Matters","text":"<p>Ontologies evolve over time:</p> <ul> <li>Labels change (e.g., \"cell cycle process\" \u2192 \"cell cycle\")</li> <li>Terms are deprecated or merged</li> <li>New terms are added</li> <li>Hierarchies are restructured</li> </ul> <p>Without a snapshot, validation results may differ depending on when you run them\u2014the same data might pass today but fail next month after an ontology update.</p>"},{"location":"caching/#versioning-strategy","title":"Versioning Strategy","text":"<pre><code>my-schema/\n\u251c\u2500\u2500 schema.yaml           # Your LinkML schema\n\u251c\u2500\u2500 cache/                # Ontology snapshot (commit this!)\n\u2502   \u251c\u2500\u2500 go/\n\u2502   \u2502   \u2514\u2500\u2500 terms.csv\n\u2502   \u2514\u2500\u2500 cl/\n\u2502       \u2514\u2500\u2500 terms.csv\n\u2514\u2500\u2500 .gitignore            # DON'T ignore cache/\n</code></pre> <p>When you release a schema version, the cache captures the exact ontology labels at that point in time. Anyone validating against that schema version gets consistent results.</p>"},{"location":"caching/#workflow","title":"Workflow","text":"<ol> <li>Initial setup: Run validation to populate cache</li> <li>Commit cache: Include <code>cache/</code> in version control</li> <li>Release together: Schema + cache = reproducible validation</li> <li>Update intentionally: When you want new ontology labels, clear cache and regenerate</li> </ol> <pre><code># Populate cache for a new release\nrm -rf cache/\nlinkml-term-validator validate-schema schema.yaml\ngit add cache/\ngit commit -m \"Update ontology snapshot for v2.0\"\n</code></pre>"},{"location":"caching/#trade-offs","title":"Trade-offs","text":"Approach Pros Cons Commit cache Reproducible, offline, fast May miss ontology updates Fresh lookups Always current Results vary over time, slower <p>For most use cases, reproducibility trumps currency\u2014you want validation to behave consistently.</p>"},{"location":"caching/#cache-safety","title":"Cache Safety","text":"<p>The cache is read-only during validation and only contains:</p> <ul> <li>CURIEs (ontology identifiers)</li> <li>Canonical labels</li> <li>Timestamps</li> </ul> <p>Cached data cannot affect validation logic, only speed up lookups.</p>"},{"location":"caching/#see-also","title":"See Also","text":"<ul> <li>Configuration - Complete configuration options</li> <li>Ontology Access - How ontology adapters work</li> </ul>"},{"location":"cli-reference/","title":"CLI Reference","text":"<p>Complete command-line interface reference for linkml-term-validator.</p>"},{"location":"cli-reference/#overview","title":"Overview","text":"<p>linkml-term-validator provides a single command <code>linkml-term-validator</code> with two subcommands:</p> <ul> <li><code>validate-schema</code> - Validate schema permissible values</li> <li><code>validate-data</code> - Validate data against dynamic enums and bindings</li> </ul>"},{"location":"cli-reference/#installation","title":"Installation","text":"<pre><code>pip install linkml-term-validator\n</code></pre> <p>Or with <code>uv</code>:</p> <pre><code>uv add linkml-term-validator\n</code></pre>"},{"location":"cli-reference/#global-options","title":"Global Options","text":"<p>These options apply to all subcommands:</p> <pre><code>linkml-term-validator [OPTIONS] COMMAND [ARGS]\n</code></pre> Option Description <code>--help</code> Show help message and exit"},{"location":"cli-reference/#validate-schema","title":"validate-schema","text":"<p>Validates that <code>meaning</code> fields in enum permissible values reference valid ontology terms with correct labels.</p>"},{"location":"cli-reference/#syntax","title":"Syntax","text":"<pre><code>linkml-term-validator validate-schema [OPTIONS] SCHEMA_PATH\n</code></pre>"},{"location":"cli-reference/#arguments","title":"Arguments","text":"Argument Type Required Description <code>SCHEMA_PATH</code> Path Yes Path to LinkML schema file (<code>.yaml</code>)"},{"location":"cli-reference/#options","title":"Options","text":"Option Type Default Description <code>--config PATH</code> Path None Path to OAK config file (<code>oak_config.yaml</code>) for per-prefix adapter configuration <code>--adapter TEXT</code> String <code>\"sqlite:obo:\"</code> Default OAK adapter string (e.g., <code>sqlite:obo:</code>, <code>ols:</code>, <code>bioportal:</code>) <code>--cache-dir PATH</code> Path <code>cache</code> Directory for caching ontology labels <code>--no-cache</code> Flag False Disable file-based caching <code>--strict</code> Flag False Treat warnings as errors <code>--verbose</code> Flag False Show detailed validation information <code>--help</code> Flag - Show help message and exit"},{"location":"cli-reference/#examples","title":"Examples","text":"<p>Basic validation:</p> <pre><code>linkml-term-validator validate-schema schema.yaml\n</code></pre> <p>With custom config:</p> <pre><code>linkml-term-validator validate-schema --config oak_config.yaml schema.yaml\n</code></pre> <p>Strict mode (warnings become errors):</p> <pre><code>linkml-term-validator validate-schema --strict schema.yaml\n</code></pre> <p>Using OLS instead of SQLite:</p> <pre><code>linkml-term-validator validate-schema --adapter ols: schema.yaml\n</code></pre> <p>Disable caching:</p> <pre><code>linkml-term-validator validate-schema --no-cache schema.yaml\n</code></pre> <p>Verbose output:</p> <pre><code>linkml-term-validator validate-schema --verbose schema.yaml\n</code></pre> <p>Custom cache directory:</p> <pre><code>linkml-term-validator validate-schema --cache-dir /tmp/ontology-cache schema.yaml\n</code></pre>"},{"location":"cli-reference/#output","title":"Output","text":"<p>Success (no issues):</p> <pre><code>\u2705 Validation passed!\n\nValidation Summary:\n  Enums checked: 2\n  Permissible values checked: 4\n  Meanings validated: 4\n  Issues found: 0\n</code></pre> <p>Failure (with issues):</p> <pre><code>\u274c ERROR: Label mismatch for GO:0008150\n    Enum: BiologicalProcessEnum\n    Permissible value: BIOLOGICAL_PROCESS\n    Expected label: biological process\n    Found label: biological_process\n\nValidation Summary:\n  Enums checked: 2\n  Permissible values checked: 4\n  Meanings validated: 4\n  Issues found: 1\n    Errors: 1\n    Warnings: 0\n</code></pre> <p>With unknown prefixes:</p> <pre><code>\u2705 Validation passed!\n\nValidation Summary:\n  Enums checked: 2\n  Permissible values checked: 5\n  Meanings validated: 4\n  Issues found: 0\n\n\u26a0\ufe0f  Unknown prefixes encountered (validation skipped):\n  - MY_CUSTOM\n  - INTERNAL\n\nConsider adding these to oak_config.yaml to enable validation.\n</code></pre>"},{"location":"cli-reference/#exit-codes","title":"Exit Codes","text":"Code Meaning 0 Success - no validation errors 1 Failure - validation errors found"},{"location":"cli-reference/#validate-data","title":"validate-data","text":"<p>Validates data instances against dynamic enums and binding constraints.</p> <p>Accepts multiple data files - each is validated independently with a summary at the end.</p>"},{"location":"cli-reference/#syntax_1","title":"Syntax","text":"<pre><code>linkml-term-validator validate-data [OPTIONS] DATA_PATHS...\n</code></pre>"},{"location":"cli-reference/#arguments_1","title":"Arguments","text":"Argument Type Required Description <code>DATA_PATHS</code> Path(s) Yes One or more paths to data files (<code>.yaml</code>, <code>.json</code>)"},{"location":"cli-reference/#options_1","title":"Options","text":"Option Type Default Description <code>--schema PATH</code> Path Required Path to LinkML schema file <code>--target-class TEXT</code> String None Target class name to validate against <code>--config PATH</code> Path None Path to OAK config file <code>--adapter TEXT</code> String <code>\"sqlite:obo:\"</code> Default OAK adapter string <code>--cache-dir PATH</code> Path <code>cache</code> Directory for caching ontology labels <code>--cache-strategy TEXT</code> String <code>progressive</code> Caching strategy for dynamic enums: <code>progressive</code> (lazy) or <code>greedy</code> (expand upfront) <code>--no-cache</code> Flag False Disable file-based caching <code>--labels</code> Flag False Validate that labels match ontology canonical labels <code>--lenient/--no-lenient</code> Flag False Lenient mode: don't fail when term IDs are not found in ontology <code>--no-dynamic-enums</code> Flag False Skip dynamic enum validation <code>--no-bindings</code> Flag False Skip binding constraint validation <code>--verbose</code> Flag False Show detailed validation information <code>--help</code> Flag - Show help message and exit"},{"location":"cli-reference/#examples_1","title":"Examples","text":"<p>Basic validation:</p> <pre><code>linkml-term-validator validate-data data.yaml --schema schema.yaml\n</code></pre> <p>With target class:</p> <pre><code>linkml-term-validator validate-data data.yaml --schema schema.yaml --target-class Person\n</code></pre> <p>With label validation:</p> <pre><code>linkml-term-validator validate-data data.yaml --schema schema.yaml --labels\n</code></pre> <p>With custom config:</p> <pre><code>linkml-term-validator validate-data data.yaml \\\n  --schema schema.yaml \\\n  --config oak_config.yaml\n</code></pre> <p>Only validate bindings (skip dynamic enums):</p> <pre><code>linkml-term-validator validate-data data.yaml \\\n  --schema schema.yaml \\\n  --no-dynamic-enums\n</code></pre> <p>Only validate dynamic enums (skip bindings):</p> <pre><code>linkml-term-validator validate-data data.yaml \\\n  --schema schema.yaml \\\n  --no-bindings\n</code></pre> <p>Validate multiple files:</p> <pre><code>linkml-term-validator validate-data data1.yaml data2.yaml data3.yaml \\\n  --schema schema.yaml\n</code></pre> <p>Validate all YAML files (shell glob):</p> <pre><code>linkml-term-validator validate-data data/*.yaml \\\n  --schema schema.yaml\n</code></pre> <p>With greedy caching (expand all terms upfront):</p> <pre><code>linkml-term-validator validate-data data.yaml \\\n  --schema schema.yaml \\\n  --cache-strategy greedy\n</code></pre> <p>Full validation with all options:</p> <pre><code>linkml-term-validator validate-data data.yaml \\\n  --schema schema.yaml \\\n  --target-class GeneAnnotation \\\n  --config oak_config.yaml \\\n  --cache-dir cache \\\n  --cache-strategy progressive \\\n  --labels \\\n  --verbose\n</code></pre>"},{"location":"cli-reference/#output_1","title":"Output","text":"<p>Success (single file):</p> <pre><code>\u2705 Validation passed\n</code></pre> <p>Success (multiple files):</p> <pre><code>\u2705 data1.yaml\n\u2705 data2.yaml\n\u2705 data3.yaml\n\n\u2705 All 3 files passed validation\n</code></pre> <p>Partial failure (multiple files):</p> <pre><code>\u2705 data1.yaml\n\n\u274c data2.yaml - 2 issue(s):\n  \u274c ERROR: Value 'GO:0005575' not in enum 'BiologicalProcessEnum'\n  \u274c ERROR: Value 'CL:9999999' not in enum 'CellTypeEnum'\n\n\u2705 data3.yaml\n\nSummary: 1/3 files failed, 2 total issue(s)\n</code></pre> <p>Failure (dynamic enum violation):</p> <pre><code>\u274c ERROR: Value 'GO:0005575' does not satisfy dynamic enum constraint\n    Class: GeneAnnotation\n    Slot: go_term.id\n    Enum: BiologicalProcessEnum\n    Expected: Descendant of GO:0008150 (biological_process)\n    Found: GO:0005575 (cellular_component)\n\nValidation Summary:\n  Dynamic enums validated: 5\n  Bindings validated: 3\n  Issues found: 1\n    Errors: 1\n</code></pre> <p>Failure (label mismatch with --labels):</p> <pre><code>\u274c ERROR: Label mismatch for GO:0007049\n    Class: GeneAnnotation\n    Slot: go_term.label\n    Expected label: cell cycle\n    Found label: cell-division cycle\n\nValidation Summary:\n  Dynamic enums validated: 5\n  Bindings validated: 3\n  Label validations: 3\n  Issues found: 1\n    Errors: 1\n</code></pre>"},{"location":"cli-reference/#exit-codes_1","title":"Exit Codes","text":"Code Meaning 0 Success - no validation errors 1 Failure - validation errors found"},{"location":"cli-reference/#common-workflows","title":"Common Workflows","text":""},{"location":"cli-reference/#cicd-validation","title":"CI/CD Validation","text":"<p>Schema validation in CI:</p> <pre><code>#!/bin/bash\nset -e  # Exit on error\n\necho \"Validating LinkML schemas...\"\nlinkml-term-validator validate-schema \\\n  --strict \\\n  --config oak_config.yaml \\\n  --cache-dir cache \\\n  src/schema/main.yaml\n\necho \"\u2705 Schema validation passed\"\n</code></pre> <p>Data validation in CI:</p> <pre><code>#!/bin/bash\nset -e\n\necho \"Validating curated data...\"\nlinkml-term-validator validate-data \\\n  data/curated/*.yaml \\\n  --schema src/schema/main.yaml \\\n  --config oak_config.yaml \\\n  --labels \\\n  --cache-dir cache\n\necho \"\u2705 Data validation passed\"\n</code></pre>"},{"location":"cli-reference/#local-development","title":"Local Development","text":"<p>Quick schema check:</p> <pre><code>linkml-term-validator validate-schema schema.yaml\n</code></pre> <p>Validate with fresh cache:</p> <pre><code>rm -rf cache/\nlinkml-term-validator validate-schema schema.yaml\n</code></pre> <p>Test with OLS (no local downloads):</p> <pre><code>linkml-term-validator validate-schema --adapter ols: --no-cache schema.yaml\n</code></pre>"},{"location":"cli-reference/#debugging","title":"Debugging","text":"<p>Verbose output:</p> <pre><code>linkml-term-validator validate-schema --verbose schema.yaml\n</code></pre> <p>Check specific data file:</p> <pre><code>linkml-term-validator validate-data \\\n  data/problematic.yaml \\\n  --schema schema.yaml \\\n  --verbose\n</code></pre>"},{"location":"cli-reference/#configuration-files","title":"Configuration Files","text":""},{"location":"cli-reference/#oak_configyaml","title":"oak_config.yaml","text":"<p>Controls which ontology adapters to use for different prefixes, and optionally the caching strategy:</p> <pre><code># Cache strategy (optional): \"progressive\" (default) or \"greedy\"\ncache_strategy: progressive\n\nontology_adapters:\n  GO: sqlite:obo:go\n  CHEBI: sqlite:obo:chebi\n  UBERON: sqlite:obo:uberon\n\n  # Skip validation\n  linkml: \"\"\n  schema: \"\"\n</code></pre> <p>Use with:</p> <pre><code>linkml-term-validator validate-schema --config oak_config.yaml schema.yaml\n</code></pre> <p>See Configuration for details.</p>"},{"location":"cli-reference/#shell-completion","title":"Shell Completion","text":""},{"location":"cli-reference/#bash","title":"Bash","text":"<pre><code># Add to ~/.bashrc\neval \"$(_LINKML_TERM_VALIDATOR_COMPLETE=bash_source linkml-term-validator)\"\n</code></pre>"},{"location":"cli-reference/#zsh","title":"Zsh","text":"<pre><code># Add to ~/.zshrc\neval \"$(_LINKML_TERM_VALIDATOR_COMPLETE=zsh_source linkml-term-validator)\"\n</code></pre>"},{"location":"cli-reference/#fish","title":"Fish","text":"<pre><code># Add to ~/.config/fish/config.fish\n_LINKML_TERM_VALIDATOR_COMPLETE=fish_source linkml-term-validator | source\n</code></pre>"},{"location":"cli-reference/#environment-variables","title":"Environment Variables","text":"Variable Description Default <code>BIOPORTAL_API_KEY</code> API key for BioPortal adapter None <code>OAK_CACHE_DIR</code> Default cache directory for OAK <code>~/.data/oaklib</code>"},{"location":"cli-reference/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli-reference/#command-not-found","title":"Command not found","text":"<p>Problem:</p> <pre><code>linkml-term-validator: command not found\n</code></pre> <p>Solution: Ensure the package is installed and your PATH is configured:</p> <pre><code>pip install linkml-term-validator\nwhich linkml-term-validator\n</code></pre>"},{"location":"cli-reference/#unknown-prefixes","title":"Unknown prefixes","text":"<p>Problem:</p> <pre><code>\u26a0\ufe0f  Unknown prefixes encountered (validation skipped):\n  - MY_ONTOLOGY\n</code></pre> <p>Solution: Add the prefix to your <code>oak_config.yaml</code>:</p> <pre><code>ontology_adapters:\n  MY_ONTOLOGY: sqlite:obo:my_ontology\n</code></pre> <p>Or use a local OBO file:</p> <pre><code>ontology_adapters:\n  MY_ONTOLOGY: simpleobo:path/to/ontology.obo\n</code></pre>"},{"location":"cli-reference/#slow-validation","title":"Slow validation","text":"<p>Problem: Validation takes a long time on first run.</p> <p>Solution: This is expected when using <code>sqlite:obo:</code> adapter for the first time. OAK is downloading and building the ontology database. Subsequent runs will be fast due to caching.</p> <p>To speed up development: - Use <code>simpleobo:</code> adapter with local OBO files for testing - Cache the <code>cache/</code> directory in CI/CD - Use <code>ols:</code> adapter to avoid local downloads (slower per query but no initial download)</p>"},{"location":"cli-reference/#stale-cache","title":"Stale cache","text":"<p>Problem: Validation shows old labels even though ontology has been updated.</p> <p>Solution: Clear the cache:</p> <pre><code>rm -rf cache/\nlinkml-term-validator validate-schema schema.yaml\n</code></pre> <p>Or disable caching:</p> <pre><code>linkml-term-validator validate-schema --no-cache schema.yaml\n</code></pre>"},{"location":"cli-reference/#see-also","title":"See Also","text":"<ul> <li>Configuration - Detailed configuration options</li> <li>Plugin Reference - Python API documentation</li> <li>Tutorials - Interactive tutorials</li> <li>Validation Types - Understanding validation types</li> <li>Anti-Hallucination Guardrails - Preventing AI hallucinations</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>This page details how to configure linkml-term-validator to control ontology access and validation behavior.</p>"},{"location":"configuration/#oak-configuration-file","title":"OAK Configuration File","text":"<p>The primary way to configure ontology access is through an <code>oak_config.yaml</code> file that maps ontology prefixes to OAK adapter strings.</p>"},{"location":"configuration/#basic-structure","title":"Basic Structure","text":"<pre><code># Cache strategy for dynamic enums (optional)\ncache_strategy: progressive  # or \"greedy\"\n\n# Ontology adapter mappings\nontology_adapters:\n  # Prefix: adapter_string\n  GO: sqlite:obo:go\n  CHEBI: sqlite:obo:chebi\n  UBERON: sqlite:obo:uberon\n</code></pre>"},{"location":"configuration/#using-the-config-file","title":"Using the Config File","text":"<p>CLI:</p> <pre><code>linkml-term-validator validate-schema --config oak_config.yaml schema.yaml\nlinkml-term-validator validate-data --config oak_config.yaml data.yaml --schema schema.yaml\n</code></pre> <p>Python API:</p> <pre><code>from linkml_term_validator.plugins import PermissibleValueMeaningPlugin\n\nplugin = PermissibleValueMeaningPlugin(oak_config_path=\"oak_config.yaml\")\n</code></pre>"},{"location":"configuration/#important-behavior","title":"Important Behavior","text":"<p>When using <code>oak_config.yaml</code>:</p> <ul> <li>ONLY prefixes listed in the config are validated</li> <li>Unlisted prefixes are tracked as \"unknown\" and reported at the end</li> <li>Unknown prefixes are NOT validated (no errors/warnings for these terms)</li> </ul> <p>This allows you to control which ontologies require validation and skip validation for prefixes you don't care about.</p>"},{"location":"configuration/#oak-adapter-strings","title":"OAK Adapter Strings","text":"<p>OAK adapter strings specify how to access an ontology. Different adapters support different backends and use cases.</p>"},{"location":"configuration/#common-adapters","title":"Common Adapters","text":""},{"location":"configuration/#sqliteobo-default-recommended","title":"sqlite:obo: (Default, Recommended)","text":"<p>Uses pre-downloaded OBO ontologies in SQLite format. Fast, works offline, caches locally.</p> <p>Usage:</p> <pre><code>ontology_adapters:\n  GO: sqlite:obo:go\n  CHEBI: sqlite:obo:chebi\n  UBERON: sqlite:obo:uberon\n</code></pre> <p>First-time setup:</p> <p>The first time you validate with a new ontology, OAK will download and build the SQLite database. This can take a few minutes but only happens once.</p> <p>Pros: - Fast queries (SQLite is efficient) - Works offline after initial download - No rate limiting - Consistent results</p> <p>Cons: - Requires initial download - Takes disk space (~100MB-1GB per ontology) - Need to manually update for latest ontology versions</p>"},{"location":"configuration/#simpleobo","title":"simpleobo:","text":"<p>Uses local OBO files directly. Good for unit tests and custom ontologies.</p> <p>Usage:</p> <pre><code>ontology_adapters:\n  MY_CUSTOM: simpleobo:path/to/my_ontology.obo\n  TEST: simpleobo:tests/data/test_ontology.obo\n</code></pre> <p>Pros: - Fast, lightweight - Perfect for testing - No network access required - Full control over ontology version</p> <p>Cons: - Limited query capabilities compared to SQLite - Only works with OBO format - Need to manage OBO files yourself</p>"},{"location":"configuration/#ols","title":"ols:","text":"<p>Uses the Ontology Lookup Service (EBI). Online service, no local downloads.</p> <p>Usage:</p> <pre><code>ontology_adapters:\n  GO: ols:\n  CHEBI: ols:\n  UBERON: ols:\n</code></pre> <p>Pros: - No local downloads - Always uses latest ontology versions - Works out-of-the-box</p> <p>Cons: - Requires internet connection - Slower than local adapters - Subject to rate limiting - Service availability dependence</p>"},{"location":"configuration/#bioportal","title":"bioportal:","text":"<p>Uses NCBO BioPortal. Requires API key.</p> <p>Usage:</p> <pre><code>ontology_adapters:\n  GO: bioportal:\n  CHEBI: bioportal:\n</code></pre> <p>Setup:</p> <p>Set <code>BIOPORTAL_API_KEY</code> environment variable:</p> <pre><code>export BIOPORTAL_API_KEY=your-api-key-here\nlinkml-term-validator validate-schema --config oak_config.yaml schema.yaml\n</code></pre> <p>Pros: - Access to many ontologies - Well-maintained service - Good coverage</p> <p>Cons: - Requires API key registration - Subject to rate limiting - Requires internet connection</p>"},{"location":"configuration/#skipping-validation-for-specific-prefixes","title":"Skipping Validation for Specific Prefixes","text":"<p>To skip validation for certain prefixes, use an empty string:</p> <pre><code>ontology_adapters:\n  GO: sqlite:obo:go\n  CHEBI: sqlite:obo:chebi\n\n  # Skip validation for these prefixes\n  xsd: \"\"\n  rdf: \"\"\n  linkml: \"\"\n  schema: \"\"\n</code></pre> <p>Terms with these prefixes will not be validated and won't generate warnings.</p>"},{"location":"configuration/#default-behavior-no-config-file","title":"Default Behavior (No Config File)","text":"<p>If you don't provide an <code>oak_config.yaml</code> file, the validator uses intelligent defaults:</p> <p>Default adapter: <code>sqlite:obo:</code></p> <p>The validator automatically creates per-prefix adapters based on the prefix in the CURIE:</p> <ul> <li><code>GO:0008150</code> \u2192 uses <code>sqlite:obo:go</code></li> <li><code>CHEBI:15377</code> \u2192 uses <code>sqlite:obo:chebi</code></li> <li><code>UBERON:0000468</code> \u2192 uses <code>sqlite:obo:uberon</code></li> <li><code>CL:0000540</code> \u2192 uses <code>sqlite:obo:cl</code></li> </ul> <p>This works for any OBO ontology that OAK knows about.</p> <p>When this works well:</p> <ul> <li>You're using standard OBO ontologies (GO, CHEBI, UBERON, CL, etc.)</li> <li>You want all ontology terms validated</li> <li>You're okay with initial download times</li> </ul> <p>When you need a config file:</p> <ul> <li>You want to use different adapters (e.g., OLS instead of SQLite)</li> <li>You want to skip validation for certain prefixes</li> <li>You have custom ontologies not in OBO</li> <li>You want to use local OBO files for testing</li> </ul>"},{"location":"configuration/#command-line-options","title":"Command-Line Options","text":""},{"location":"configuration/#cache-control","title":"Cache Control","text":"<p>Cache directory:</p> <pre><code>linkml-term-validator validate-schema --cache-dir /path/to/cache schema.yaml\n</code></pre> <p>Default: <code>./cache</code></p> <p>Disable caching:</p> <pre><code>linkml-term-validator validate-schema --no-cache schema.yaml\n</code></pre> <p>This forces fresh lookups from the ontology source every time. Useful for testing or when you want guaranteed fresh data.</p> <p>Cache strategy (data validation):</p> <pre><code># Progressive (default) - validates lazily, caches valid terms as encountered\nlinkml-term-validator validate-data --cache-strategy progressive data.yaml -s schema.yaml\n\n# Greedy - expands entire enum upfront and caches all terms\nlinkml-term-validator validate-data --cache-strategy greedy data.yaml -s schema.yaml\n</code></pre> <p>See Caching for details on when to use each strategy.</p>"},{"location":"configuration/#validation-behavior","title":"Validation Behavior","text":"<p>Strict mode:</p> <pre><code>linkml-term-validator validate-schema --strict schema.yaml\n</code></pre> <p>Treats all warnings as errors. Useful for CI/CD pipelines where you want strict enforcement.</p> <p>Verbose output:</p> <pre><code>linkml-term-validator validate-schema --verbose schema.yaml\n</code></pre> <p>Shows detailed information about what's being validated and any issues encountered.</p> <p>Label validation (data validation only):</p> <pre><code>linkml-term-validator validate-data --labels data.yaml --schema schema.yaml\n</code></pre> <p>Also validates that labels in the data match the canonical labels from the ontology.</p> <p>Selective plugin usage (data validation only):</p> <pre><code># Only validate dynamic enums, skip bindings\nlinkml-term-validator validate-data --no-bindings data.yaml --schema schema.yaml\n\n# Only validate bindings, skip dynamic enums\nlinkml-term-validator validate-data --no-dynamic-enums data.yaml --schema schema.yaml\n</code></pre>"},{"location":"configuration/#example-configurations","title":"Example Configurations","text":""},{"location":"configuration/#standard-obo-ontologies","title":"Standard OBO Ontologies","text":"<pre><code># oak_config.yaml\nontology_adapters:\n  GO: sqlite:obo:go\n  CHEBI: sqlite:obo:chebi\n  UBERON: sqlite:obo:uberon\n  CL: sqlite:obo:cl\n  MONDO: sqlite:obo:mondo\n  HP: sqlite:obo:hp\n</code></pre>"},{"location":"configuration/#mixed-onlineoffline","title":"Mixed Online/Offline","text":"<pre><code># oak_config.yaml\nontology_adapters:\n  # Use SQLite for commonly-used ontologies\n  GO: sqlite:obo:go\n  CHEBI: sqlite:obo:chebi\n\n  # Use OLS for rarely-used ontologies (avoid downloads)\n  FYPO: ols:\n  WBPhenotype: ols:\n\n  # Skip validation for metadata prefixes\n  linkml: \"\"\n  schema: \"\"\n</code></pre>"},{"location":"configuration/#local-testing-setup","title":"Local Testing Setup","text":"<pre><code># oak_config.yaml (for tests)\nontology_adapters:\n  # Use local OBO file for fast, offline testing\n  TEST: simpleobo:tests/data/test_ontology.obo\n\n  # Real ontologies for integration tests\n  GO: sqlite:obo:go\n</code></pre>"},{"location":"configuration/#custom-ontology","title":"Custom Ontology","text":"<pre><code># oak_config.yaml\nontology_adapters:\n  # Standard ontologies\n  GO: sqlite:obo:go\n  CHEBI: sqlite:obo:chebi\n\n  # Your custom ontology from local file\n  MY_ORG: simpleobo:ontologies/my_org_ontology.obo\n</code></pre>"},{"location":"configuration/#cicd-pipeline","title":"CI/CD Pipeline","text":"<p>For CI/CD, you typically want:</p> <ul> <li>Strict mode - treat warnings as errors</li> <li>Configured adapters - control which ontologies are validated</li> <li>Caching - cache between runs for speed</li> </ul> <p>GitHub Actions example:</p> <pre><code># .github/workflows/validate.yml\nname: Validate Schemas\n\non: [push, pull_request]\n\njobs:\n  validate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.10'\n\n      - name: Install dependencies\n        run: |\n          pip install linkml-term-validator\n\n      - name: Cache ontology databases\n        uses: actions/cache@v3\n        with:\n          path: cache\n          key: ontology-cache-${{ hashFiles('oak_config.yaml') }}\n\n      - name: Validate schemas\n        run: |\n          linkml-term-validator validate-schema \\\n            --strict \\\n            --config oak_config.yaml \\\n            --cache-dir cache \\\n            src/schema/\n</code></pre>"},{"location":"configuration/#plugin-configuration-python-api","title":"Plugin Configuration (Python API)","text":"<p>When using plugins programmatically, you can configure them via constructor arguments:</p>"},{"location":"configuration/#permissiblevaluemeaningplugin","title":"PermissibleValueMeaningPlugin","text":"<pre><code>from linkml_term_validator.plugins import PermissibleValueMeaningPlugin\n\nplugin = PermissibleValueMeaningPlugin(\n    oak_adapter_string=\"sqlite:obo:\",  # Default adapter\n    oak_config_path=\"oak_config.yaml\",  # Optional config file\n    strict_mode=False,                   # Treat warnings as errors\n    cache_labels=True,                   # Enable file-based caching\n    cache_dir=\"cache\",                   # Cache directory\n)\n</code></pre>"},{"location":"configuration/#dynamicenumplugin","title":"DynamicEnumPlugin","text":"<pre><code>from linkml_term_validator.plugins import DynamicEnumPlugin\nfrom linkml_term_validator.models import CacheStrategy\n\nplugin = DynamicEnumPlugin(\n    oak_adapter_string=\"sqlite:obo:\",\n    oak_config_path=\"oak_config.yaml\",\n    cache_labels=True,\n    cache_dir=\"cache\",\n    cache_strategy=CacheStrategy.PROGRESSIVE,  # or GREEDY\n)\n</code></pre>"},{"location":"configuration/#bindingvalidationplugin","title":"BindingValidationPlugin","text":"<pre><code>from linkml_term_validator.plugins import BindingValidationPlugin\nfrom linkml_term_validator.models import CacheStrategy\n\nplugin = BindingValidationPlugin(\n    oak_adapter_string=\"sqlite:obo:\",\n    oak_config_path=\"oak_config.yaml\",\n    validate_labels=True,  # Also check labels match ontology\n    cache_labels=True,\n    cache_dir=\"cache\",\n    cache_strategy=CacheStrategy.PROGRESSIVE,  # or GREEDY\n)\n</code></pre>"},{"location":"configuration/#linkml-validate-configuration","title":"linkml-validate Configuration","text":"<p>When using plugins with <code>linkml-validate</code>, configure them via YAML:</p> <pre><code># validation_config.yaml\nschema: schema.yaml\ntarget_class: Person\n\ndata_sources:\n  - data.yaml\n\nplugins:\n  JsonschemaValidationPlugin:\n    closed: true\n\n  \"linkml_term_validator.plugins.DynamicEnumPlugin\":\n    oak_adapter_string: \"sqlite:obo:\"\n    cache_labels: true\n    cache_dir: cache\n    cache_strategy: progressive  # or \"greedy\"\n    oak_config_path: oak_config.yaml\n\n  \"linkml_term_validator.plugins.BindingValidationPlugin\":\n    oak_adapter_string: \"sqlite:obo:\"\n    validate_labels: true\n    cache_labels: true\n    cache_dir: cache\n    cache_strategy: progressive  # or \"greedy\"\n    oak_config_path: oak_config.yaml\n</code></pre> <p>Then:</p> <pre><code>linkml-validate --config validation_config.yaml\n</code></pre>"},{"location":"configuration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"configuration/#unknown-prefix-warnings","title":"\"Unknown prefix\" warnings","text":"<p>Symptom: You see warnings like:</p> <pre><code>\u26a0\ufe0f  Unknown prefixes encountered (validation skipped):\n  - MY_CUSTOM\n  - SOME_ONTOLOGY\n</code></pre> <p>Cause: These prefixes aren't in your <code>oak_config.yaml</code> (or you're not using a config file and OAK doesn't recognize them).</p> <p>Solution: Add them to your config file:</p> <pre><code>ontology_adapters:\n  MY_CUSTOM: simpleobo:path/to/ontology.obo\n  SOME_ONTOLOGY: sqlite:obo:some_ontology\n</code></pre> <p>Or, if you don't want to validate them, explicitly skip:</p> <pre><code>ontology_adapters:\n  MY_CUSTOM: \"\"\n</code></pre>"},{"location":"configuration/#downloading-mydbgz-errors","title":"\"Downloading my.db.gz\" errors","text":"<p>Symptom: Long download times or errors downloading ontology databases.</p> <p>Cause: Using <code>sqlite:obo:</code> adapter for the first time with a new ontology.</p> <p>Solutions:</p> <ol> <li>Be patient - first download can take 5-10 minutes for large ontologies</li> <li>Use local files for testing - switch to <code>simpleobo:</code> for unit tests</li> <li>Pre-download in CI/CD - cache the <code>cache/</code> directory between runs</li> <li>Use OLS - switch to <code>ols:</code> adapter to avoid downloads</li> </ol>"},{"location":"configuration/#stale-cache-data","title":"Stale cache data","text":"<p>Symptom: Validation shows old labels even though ontology has been updated.</p> <p>Cause: File-based cache hasn't been refreshed.</p> <p>Solution:</p> <pre><code># Clear cache and re-validate\nrm -rf cache/\nlinkml-term-validator validate-schema schema.yaml\n</code></pre> <p>Or use <code>--no-cache</code> to bypass caching:</p> <pre><code>linkml-term-validator validate-schema --no-cache schema.yaml\n</code></pre>"},{"location":"configuration/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Complete command-line documentation</li> <li>Plugin Reference - Python API documentation</li> <li>Ontology Access - How OAK adapters work</li> <li>Caching - Understanding the caching system</li> </ul>"},{"location":"data-validation/","title":"Data Validation Reference (Dynamic Enums)","text":"<p>This reference covers validation of data values against dynamic enums\u2014ensuring that data values satisfy ontology-based constraints defined via <code>reachable_from</code>, <code>matches</code>, or <code>concepts</code>.</p>"},{"location":"data-validation/#overview","title":"Overview","text":"<p>Data validation uses the DynamicEnumPlugin to validate that data values satisfy dynamic enum constraints. Unlike static enums where valid values are listed explicitly, dynamic enums define valid values via ontology queries evaluated at validation time.</p>"},{"location":"data-validation/#cli-usage","title":"CLI Usage","text":"<pre><code># Basic data validation\nlinkml-term-validator validate-data data.yaml --schema schema.yaml\n\n# With target class\nlinkml-term-validator validate-data data.yaml -s schema.yaml -t Person\n\n# With custom OAK configuration\nlinkml-term-validator validate-data data.yaml -s schema.yaml --oak-config oak_config.yaml\n\n# Multiple data files\nlinkml-term-validator validate-data data1.yaml data2.yaml -s schema.yaml\n</code></pre>"},{"location":"data-validation/#cli-options","title":"CLI Options","text":"Option Description <code>--schema</code>, <code>-s</code> Path to LinkML schema (required) <code>--target-class</code>, <code>-t</code> Target class for validation <code>--oak-adapter</code> OAK adapter string (default: <code>sqlite:obo:</code>) <code>--oak-config</code> Path to OAK configuration file <code>--cache-dir</code> Directory for cache files (default: <code>cache</code>) <code>--verbose</code> / <code>-v</code> Enable verbose output"},{"location":"data-validation/#dynamic-enum-syntax","title":"Dynamic Enum Syntax","text":""},{"location":"data-validation/#reachable_from-ontology-traversal","title":"<code>reachable_from</code> - Ontology Traversal","text":"<p>The most common pattern\u2014allows any term reachable from source nodes via specified relationships:</p> <pre><code>enums:\n  NeuronTypeEnum:\n    reachable_from:\n      source_ontology: sqlite:obo:cl\n      source_nodes:\n        - CL:0000540           # neuron\n      relationship_types:\n        - rdfs:subClassOf\n      include_self: false      # Default: false\n</code></pre>"},{"location":"data-validation/#parameters","title":"Parameters","text":"Parameter Required Description <code>source_ontology</code> Yes OAK adapter string (e.g., <code>sqlite:obo:cl</code>, <code>obo:go</code>) <code>source_nodes</code> Yes Root term(s) for traversal <code>relationship_types</code> Yes Edge types to traverse <code>include_self</code> No Include source nodes in results (default: <code>false</code>)"},{"location":"data-validation/#important-semantics","title":"Important Semantics","text":"<p>Source nodes are EXCLUDED by default. This means:</p> <pre><code># This enum allows descendants of CL:0000540, but NOT CL:0000540 itself\nenums:\n  NeuronTypeEnum:\n    reachable_from:\n      source_nodes:\n        - CL:0000540  # neuron\n</code></pre> <pre><code># Valid data - a specific neuron type (descendant)\ncell_type: CL:0000117  # CNS neuron - is-a neuron\n\n# INVALID - the source node itself\ncell_type: CL:0000540  # neuron - excluded by default!\n</code></pre> <p>To include the source node, set <code>include_self: true</code>:</p> <pre><code>enums:\n  NeuronOrSubtype:\n    reachable_from:\n      source_nodes:\n        - CL:0000540\n      include_self: true      # Now CL:0000540 is also valid\n</code></pre>"},{"location":"data-validation/#matches-pattern-matching","title":"<code>matches</code> - Pattern Matching","text":"<p>Allows values matching a regex pattern:</p> <pre><code>enums:\n  GOTermPattern:\n    matches:\n      source_ontology: sqlite:obo:go\n      pattern: \"GO:[0-9]{7}\"   # GO term format\n</code></pre>"},{"location":"data-validation/#concepts-explicit-list","title":"<code>concepts</code> - Explicit List","text":"<p>Allows a specific set of concepts (similar to static enum but defined differently):</p> <pre><code>enums:\n  SpecificTerms:\n    concepts:\n      - CL:0000540   # neuron\n      - CL:0000746   # cardiomyocyte\n      - CL:0000182   # hepatocyte\n</code></pre>"},{"location":"data-validation/#validation-process","title":"Validation Process","text":"<p>For each slot in the data with a dynamic enum range:</p> <ol> <li>Extract the enum definition from the schema</li> <li>Evaluate the constraint:</li> <li>For <code>reachable_from</code>: Query the ontology for descendants</li> <li>For <code>matches</code>: Apply regex to the value</li> <li>For <code>concepts</code>: Check membership</li> <li>Report violations as ERROR severity</li> </ol>"},{"location":"data-validation/#examples","title":"Examples","text":""},{"location":"data-validation/#complete-schema-and-data-example","title":"Complete Schema and Data Example","text":"<p>Schema (<code>schema.yaml</code>):</p> <pre><code>id: https://example.org/cell-schema\nname: cell-schema\nprefixes:\n  CL: http://purl.obolibrary.org/obo/CL_\n  linkml: https://w3id.org/linkml/\n\nclasses:\n  CellAnnotation:\n    attributes:\n      id:\n        range: string\n        identifier: true\n      cell_type:\n        range: NeuronTypeEnum      # Uses dynamic enum\n\nenums:\n  NeuronTypeEnum:\n    description: Any type of neuron\n    reachable_from:\n      source_ontology: sqlite:obo:cl\n      source_nodes:\n        - CL:0000540              # neuron\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre> <p>Valid data (<code>valid_data.yaml</code>):</p> <pre><code>- id: cell-001\n  cell_type: CL:0000117           # CNS neuron - valid\n\n- id: cell-002\n  cell_type: CL:0000111           # peripheral neuron - valid\n</code></pre> <p>Invalid data (<code>invalid_data.yaml</code>):</p> <pre><code>- id: cell-001\n  cell_type: CL:0000540           # neuron - INVALID (source node excluded)\n\n- id: cell-002\n  cell_type: GO:0008150           # biological_process - INVALID (wrong ontology)\n\n- id: cell-003\n  cell_type: CL:0000746           # cardiomyocyte - INVALID (not a neuron)\n</code></pre> <p>Validation:</p> <pre><code>linkml-term-validator validate-data valid_data.yaml -s schema.yaml -t CellAnnotation\n# \u2705 Valid\n\nlinkml-term-validator validate-data invalid_data.yaml -s schema.yaml -t CellAnnotation\n# \u274c 3 errors\n</code></pre>"},{"location":"data-validation/#multiple-source-nodes","title":"Multiple Source Nodes","text":"<p>Allow terms from multiple branches:</p> <pre><code>enums:\n  CancerOrInfectiousDisease:\n    reachable_from:\n      source_ontology: sqlite:obo:mondo\n      source_nodes:\n        - MONDO:0004992           # cancer\n        - MONDO:0005550           # infectious disease\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre>"},{"location":"data-validation/#part-of-relationships","title":"Part-of Relationships","text":"<p>Use <code>BFO:0000050</code> (part-of) instead of <code>rdfs:subClassOf</code>:</p> <pre><code>enums:\n  BrainPartEnum:\n    reachable_from:\n      source_ontology: sqlite:obo:uberon\n      source_nodes:\n        - UBERON:0000955          # brain\n      relationship_types:\n        - BFO:0000050             # part-of\n</code></pre>"},{"location":"data-validation/#combined-relationships","title":"Combined Relationships","text":"<p>Query multiple relationship types:</p> <pre><code>enums:\n  BrainStructureEnum:\n    reachable_from:\n      source_ontology: sqlite:obo:uberon\n      source_nodes:\n        - UBERON:0000955          # brain\n      relationship_types:\n        - rdfs:subClassOf         # subtypes\n        - BFO:0000050             # parts\n</code></pre>"},{"location":"data-validation/#python-api","title":"Python API","text":"<pre><code>from linkml.validator import Validator\nfrom linkml_runtime.loaders import yaml_loader\nfrom linkml_term_validator.plugins import DynamicEnumPlugin\n\n# Create plugin\nplugin = DynamicEnumPlugin(\n    oak_adapter_string=\"sqlite:obo:\",\n    cache_labels=True,\n    cache_dir=\"cache\",\n)\n\n# Create validator\nvalidator = Validator(\n    schema=\"schema.yaml\",\n    validation_plugins=[plugin]\n)\n\n# Validate with YamlLoader\nloader = yaml_loader.YamlLoader()\nreport = validator.validate_source(\n    loader,\n    \"data.yaml\",\n    target_class=\"CellAnnotation\"\n)\n\n# Check results\nif len(report.results) == 0:\n    print(\"All dynamic enum constraints satisfied\")\nelse:\n    for result in report.results:\n        print(f\"{result.severity.name}: {result.message}\")\n</code></pre>"},{"location":"data-validation/#plugin-parameters","title":"Plugin Parameters","text":"Parameter Type Default Description <code>oak_adapter_string</code> <code>str</code> <code>\"sqlite:obo:\"</code> Default OAK adapter <code>oak_config_path</code> <code>str \\| None</code> <code>None</code> Path to OAK config file <code>cache_labels</code> <code>bool</code> <code>True</code> Enable file-based caching <code>cache_dir</code> <code>str</code> <code>\"cache\"</code> Cache directory"},{"location":"data-validation/#error-messages","title":"Error Messages","text":""},{"location":"data-validation/#value-not-in-enum","title":"Value Not in Enum","text":"<pre><code>ERROR: Value 'GO:0008150' is not valid for enum 'NeuronTypeEnum'\n  slot: cell_type\n  instance_index: 1\n</code></pre> <p>Cause: The value doesn't satisfy the <code>reachable_from</code> constraint\u2014it's not a descendant of any source node.</p>"},{"location":"data-validation/#source-node-used-directly","title":"Source Node Used Directly","text":"<pre><code>ERROR: Value 'CL:0000540' is not valid for enum 'NeuronTypeEnum'\n  slot: cell_type\n</code></pre> <p>Cause: The source node is used directly, but <code>include_self</code> is <code>false</code> (default).</p> <p>Solution: Either: 1. Use a descendant term instead 2. Set <code>include_self: true</code> in the enum definition</p>"},{"location":"data-validation/#performance-considerations","title":"Performance Considerations","text":""},{"location":"data-validation/#caching","title":"Caching","text":"<p>The plugin uses two-level caching:</p> <ol> <li>In-memory cache: Speeds up repeated queries in the same session</li> <li>File-based cache: Persists between sessions (stored in <code>cache_dir</code>)</li> </ol> <p>For large-scale validation, consider:</p> <pre><code>plugin = DynamicEnumPlugin(\n    cache_labels=True,\n    cache_dir=\"cache\"      # Persistent cache directory\n)\n</code></pre>"},{"location":"data-validation/#ontology-download","title":"Ontology Download","text":"<p>On first use, <code>sqlite:obo:</code> adapters download ontology databases. This may take time but only happens once:</p> <pre><code>Downloading GO database... (first run only)\n</code></pre> <p>For offline use, pre-download ontologies:</p> <pre><code># Pre-download with OAK\nrunoak -i sqlite:obo:go info GO:0008150\nrunoak -i sqlite:obo:cl info CL:0000540\n</code></pre>"},{"location":"data-validation/#common-issues","title":"Common Issues","text":""},{"location":"data-validation/#ontology-not-found","title":"\"Ontology not found\"","text":"<pre><code>ERROR: Could not load ontology for prefix 'CUSTOM'\n</code></pre> <p>Solution: Configure the prefix in <code>oak_config.yaml</code>:</p> <pre><code>ontology_adapters:\n  CUSTOM: simpleobo:path/to/custom.obo\n</code></pre>"},{"location":"data-validation/#slow-validation","title":"Slow Validation","text":"<p>Cause: Large ontology queries or network latency.</p> <p>Solutions: 1. Enable caching (<code>cache_labels=True</code>) 2. Use <code>sqlite:obo:</code> adapters instead of <code>ols:</code> 3. Pre-download ontologies</p>"},{"location":"data-validation/#multivalued-slots","title":"Multivalued Slots","text":"<p>Dynamic enum validation works with multivalued slots:</p> <pre><code>classes:\n  CellCollection:\n    attributes:\n      cell_types:\n        range: CellTypeEnum\n        multivalued: true       # Each value is validated\n</code></pre>"},{"location":"data-validation/#see-also","title":"See Also","text":"<ul> <li>Enumerations - Understanding dynamic enum concepts</li> <li>Binding Validation - Validating complex objects</li> <li>Configuration - OAK adapter configuration</li> <li>Plugin Reference - Complete API reference</li> </ul>"},{"location":"enumerations/","title":"Enumerations in LinkML: Static and Dynamic","text":"<p>LinkML provides two approaches to constraining values: static enums with explicit permissible values, and dynamic enums that query ontologies at validation time. Understanding when to use each is key to effective schema design.</p>"},{"location":"enumerations/#static-enums","title":"Static Enums","text":"<p>Static enums define a fixed list of allowed values directly in the schema.</p>"},{"location":"enumerations/#basic-static-enum","title":"Basic Static Enum","text":"<pre><code>enums:\n  SampleStatusEnum:\n    permissible_values:\n      PENDING:\n      PROCESSING:\n      COMPLETED:\n      FAILED:\n</code></pre> <p>Data must match one of these exact strings:</p> <pre><code># Valid\nstatus: COMPLETED\n\n# Invalid - \"completed\" not in enum\nstatus: completed\n</code></pre>"},{"location":"enumerations/#static-enum-with-ontology-mappings","title":"Static Enum with Ontology Mappings","text":"<p>The <code>meaning</code> property connects permissible values to ontology terms:</p> <pre><code>prefixes:\n  GO: http://purl.obolibrary.org/obo/GO_\n\nenums:\n  BiologicalProcessEnum:\n    permissible_values:\n      CELL_CYCLE:\n        title: cell cycle\n        meaning: GO:0007049\n      DNA_REPLICATION:\n        title: DNA replication\n        meaning: GO:0006260\n      APOPTOSIS:\n        title: apoptotic process\n        meaning: GO:0006915\n</code></pre> <p>This approach:</p> <ul> <li>Uses human-readable keys (<code>CELL_CYCLE</code>)</li> <li>Provides display titles (<code>cell cycle</code>)</li> <li>Links to authoritative ontology terms (<code>GO:0007049</code>)</li> </ul>"},{"location":"enumerations/#when-to-use-static-enums","title":"When to Use Static Enums","text":"<p>Static enums are appropriate when:</p> Scenario Example Small, stable value sets Status codes, priority levels Domain-specific codes Internal project identifiers Curated subsets Carefully selected ontology terms Performance-critical No runtime ontology lookup needed"},{"location":"enumerations/#validation-of-static-enums","title":"Validation of Static Enums","text":"<p>Schema validation (<code>PermissibleValueMeaningPlugin</code>) checks:</p> <ul> <li>Each <code>meaning</code> CURIE exists in the ontology</li> <li>The <code>title</code> matches the ontology's label (optional)</li> </ul> <pre><code>linkml-term-validator validate-schema schema.yaml\n</code></pre>"},{"location":"enumerations/#dynamic-enums","title":"Dynamic Enums","text":"<p>Dynamic enums define allowed values via ontology queries, evaluated at validation time.</p>"},{"location":"enumerations/#basic-dynamic-enum","title":"Basic Dynamic Enum","text":"<pre><code>enums:\n  CellTypeEnum:\n    reachable_from:\n      source_ontology: obo:cl\n      source_nodes:\n        - CL:0000000  # cell\n      include_self: false\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre> <p>This allows any descendant of \"cell\" in the Cell Ontology\u2014potentially thousands of terms\u2014without listing each one.</p>"},{"location":"enumerations/#dynamic-enum-parameters","title":"Dynamic Enum Parameters","text":"Parameter Description Example <code>source_ontology</code> OAK adapter string <code>obo:cl</code>, <code>sqlite:obo:go</code> <code>source_nodes</code> Root term(s) for the query <code>[CL:0000540]</code> <code>relationship_types</code> Edge types to traverse <code>[rdfs:subClassOf]</code> <code>include_self</code> Include source nodes in results <code>true</code> or <code>false</code>"},{"location":"enumerations/#common-patterns","title":"Common Patterns","text":"<p>All subtypes of a term:</p> <pre><code>enums:\n  NeuronTypeEnum:\n    reachable_from:\n      source_ontology: obo:cl\n      source_nodes:\n        - CL:0000540  # neuron\n      include_self: false\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre> <p>Multiple source nodes:</p> <pre><code>enums:\n  CancerOrInfectiousDisease:\n    reachable_from:\n      source_ontology: obo:mondo\n      source_nodes:\n        - MONDO:0004992  # cancer\n        - MONDO:0005550  # infectious disease\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre> <p>Part-of relationships:</p> <pre><code>enums:\n  BrainPartEnum:\n    reachable_from:\n      source_ontology: obo:uberon\n      source_nodes:\n        - UBERON:0000955  # brain\n      relationship_types:\n        - BFO:0000050  # part-of\n</code></pre>"},{"location":"enumerations/#when-to-use-dynamic-enums","title":"When to Use Dynamic Enums","text":"<p>Dynamic enums are appropriate when:</p> Scenario Example Large value sets All cell types, all diseases Evolving ontologies New terms added regularly Branch-based constraints \"Any GO biological process\" Avoiding maintenance Don't want to update schema with each ontology release"},{"location":"enumerations/#validation-of-dynamic-enums","title":"Validation of Dynamic Enums","text":"<p>Data validation (<code>DynamicEnumPlugin</code>) checks:</p> <ul> <li>The data value exists in the expanded enum</li> <li>Expansion queries the ontology via OAK</li> </ul> <pre><code>linkml-term-validator validate-data data.yaml -s schema.yaml -t ClassName\n</code></pre>"},{"location":"enumerations/#static-vs-dynamic-trade-offs","title":"Static vs Dynamic: Trade-offs","text":"Aspect Static Enum Dynamic Enum Schema size Grows with values Constant (just the query) Validation speed Fast (string match) Slower (ontology query) Maintenance Manual updates Automatic with ontology Offline use Always works Needs ontology access Explicit control Full control over values Delegate to ontology JSON Schema export Direct Requires materialization"},{"location":"enumerations/#materializing-dynamic-enums","title":"Materializing Dynamic Enums","text":"<p>For tools that don't support dynamic queries (like JSON Schema validators), you can materialize dynamic enums into static lists:</p> <pre><code># Using OAK's vskit\nvskit expand -s schema.yaml -o schema_expanded.yaml\n</code></pre> <p>This creates a schema with static enums populated from the query results.</p>"},{"location":"enumerations/#combining-static-and-dynamic","title":"Combining Static and Dynamic","text":"<p>You can combine both approaches:</p> <pre><code>enums:\n  # Static subset for common cases\n  CommonCellTypes:\n    permissible_values:\n      NEURON:\n        meaning: CL:0000540\n      HEPATOCYTE:\n        meaning: CL:0000182\n      CARDIOMYOCYTE:\n        meaning: CL:0000746\n\n  # Dynamic for full flexibility\n  AllCellTypes:\n    reachable_from:\n      source_ontology: obo:cl\n      source_nodes:\n        - CL:0000000\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre>"},{"location":"enumerations/#see-also","title":"See Also","text":"<ul> <li>Ontologies in LinkML - Background on ontologies</li> <li>Bindings Explained - Constraining complex objects</li> <li>Schema Validation Reference - Validating static enum meanings</li> </ul>"},{"location":"enumerations/#external-resources","title":"External Resources","text":"<ul> <li>LinkML Semantic Enumerations</li> <li>LinkML Tutorial: Enumerations</li> </ul>"},{"location":"howto-bindings/","title":"How-To: Validate Bindings with Dynamic Enums","text":"<p>This guide shows you how to validate ontology term bindings in nested objects, including validation against dynamic enum closures and catching fabricated term IDs.</p>"},{"location":"howto-bindings/#prerequisites","title":"Prerequisites","text":"<ul> <li>linkml-term-validator installed</li> <li>A LinkML schema with bindings</li> <li>Data to validate</li> <li>(Optional) An oak_config.yaml for custom ontology adapters</li> </ul>"},{"location":"howto-bindings/#goal","title":"Goal","text":"<p>Validate that:</p> <ol> <li>Term IDs in nested objects belong to the correct ontology branch (closure validation)</li> <li>Term IDs actually exist in the ontology (strict mode)</li> <li>(Optionally) Labels match the ontology's canonical labels</li> </ol>"},{"location":"howto-bindings/#step-1-define-your-schema-with-bindings","title":"Step 1: Define Your Schema with Bindings","text":"<p>Create a schema with a reusable term class and bindings that constrain the <code>id</code> field to a dynamic enum:</p> <pre><code># schema.yaml\nid: https://example.org/gene-annotations\nname: gene-annotations\nprefixes:\n  GO: http://purl.obolibrary.org/obo/GO_\n  linkml: https://w3id.org/linkml/\n\ndefault_prefix: gene-annotations\ndefault_range: string\n\nclasses:\n  GeneAnnotation:\n    tree_root: true\n    attributes:\n      gene_id:\n        identifier: true\n      process:\n        description: Biological process annotation\n        range: Term\n        inlined: true\n        bindings:\n          - binds_value_of: id\n            range: BiologicalProcessEnum\n\n  Term:\n    description: Reusable ontology term class\n    attributes:\n      id:\n        description: CURIE (e.g., GO:0007049)\n      label:\n        description: Human-readable label\n        implements:\n          - rdfs:label\n\nenums:\n  BiologicalProcessEnum:\n    description: GO biological processes\n    reachable_from:\n      source_ontology: sqlite:obo:go\n      source_nodes:\n        - GO:0008150  # biological_process\n      relationship_types:\n        - rdfs:subClassOf\n      include_self: true\n</code></pre> <p>Key points:</p> <ul> <li><code>bindings</code> on the <code>process</code> slot constrains <code>term.id</code> to <code>BiologicalProcessEnum</code></li> <li><code>reachable_from</code> defines a dynamic enum based on ontology traversal</li> <li><code>implements: [rdfs:label]</code> marks the label field for validation</li> </ul>"},{"location":"howto-bindings/#step-2-create-test-data","title":"Step 2: Create Test Data","text":"<p>Valid data (<code>valid_data.yaml</code>):</p> <pre><code>gene_id: BRCA1\nprocess:\n  id: GO:0007049    # cell cycle - IS a biological process\n  label: cell cycle\n</code></pre> <p>Invalid data - wrong branch (<code>wrong_branch.yaml</code>):</p> <pre><code>gene_id: BRCA1\nprocess:\n  id: GO:0005634    # nucleus - NOT a biological process (it's a cellular component)\n  label: nucleus\n</code></pre> <p>Invalid data - fabricated ID (<code>fabricated.yaml</code>):</p> <pre><code>gene_id: BRCA1\nprocess:\n  id: GO:9999999    # Doesn't exist in GO!\n  label: made up term\n</code></pre>"},{"location":"howto-bindings/#step-3-run-validation","title":"Step 3: Run Validation","text":""},{"location":"howto-bindings/#basic-binding-validation","title":"Basic Binding Validation","text":"<pre><code># Validates against the dynamic enum closure\nlinkml-term-validator validate-data valid_data.yaml -s schema.yaml -t GeneAnnotation\n</code></pre> <p>Output:</p> <pre><code>Validation passed\n</code></pre>"},{"location":"howto-bindings/#catch-wrong-branch","title":"Catch Wrong Branch","text":"<pre><code>linkml-term-validator validate-data wrong_branch.yaml -s schema.yaml -t GeneAnnotation\n</code></pre> <p>Output:</p> <pre><code>Validation failed with 1 issue(s):\n\n  ERROR: Value 'GO:0005634' not in dynamic enum (expanded from ontology) 'BiologicalProcessEnum'\n      path: process\n      slot: process\n      field: id\n      allowed_values: 29688 terms\n</code></pre>"},{"location":"howto-bindings/#catch-fabricated-ids-strict-mode","title":"Catch Fabricated IDs (Strict Mode)","text":"<p>By default, strict mode is enabled. This catches fabricated term IDs:</p> <pre><code>linkml-term-validator validate-data fabricated.yaml -s schema.yaml -t GeneAnnotation\n</code></pre> <p>Output:</p> <pre><code>Validation failed with 2 issue(s):\n\n  ERROR: Value 'GO:9999999' not in dynamic enum (expanded from ontology) 'BiologicalProcessEnum'\n      ...\n  ERROR: Term 'GO:9999999' not found in ontology\n      ...\n      prefix: GO (configured in oak_config)\n</code></pre>"},{"location":"howto-bindings/#disable-strict-mode-lenient","title":"Disable Strict Mode (Lenient)","text":"<p>If you want to skip the existence check:</p> <pre><code>linkml-term-validator validate-data fabricated.yaml -s schema.yaml -t GeneAnnotation --lenient\n</code></pre> <p>This will only report the closure error, not the \"term not found\" error.</p>"},{"location":"howto-bindings/#step-4-add-label-validation-anti-hallucination","title":"Step 4: Add Label Validation (Anti-Hallucination)","text":"<p>Enable label validation to catch mismatched labels:</p> <pre><code>linkml-term-validator validate-data data.yaml -s schema.yaml -t GeneAnnotation --labels\n</code></pre> <p>If the data has:</p> <pre><code>process:\n  id: GO:0007049\n  label: DNA repair  # WRONG! Should be \"cell cycle\"\n</code></pre> <p>Output:</p> <pre><code>WARNING: Label mismatch for GO:0007049\n  Expected: \"DNA repair\"\n  Ontology: \"cell cycle\"\n</code></pre>"},{"location":"howto-bindings/#step-5-use-custom-ontology-configuration","title":"Step 5: Use Custom Ontology Configuration","text":"<p>For local ontologies or specific adapters, create an <code>oak_config.yaml</code>:</p> <pre><code># oak_config.yaml\nontology_adapters:\n  GO: sqlite:obo:go\n  HP: sqlite:obo:hp\n  MONDO: sqlite:obo:mondo\n  # For local OBO files:\n  # TEST: simpleobo:path/to/test.obo\n</code></pre> <p>Then reference it:</p> <pre><code>linkml-term-validator validate-data data.yaml -s schema.yaml -t GeneAnnotation \\\n    --config oak_config.yaml\n</code></pre>"},{"location":"howto-bindings/#python-api","title":"Python API","text":"<pre><code>from linkml.validator import Validator\nfrom linkml.validator.loaders import YamlLoader\nfrom linkml_term_validator.plugins import BindingValidationPlugin\n\n# Create plugin with options\nplugin = BindingValidationPlugin(\n    validate_labels=True,      # Check labels match ontology\n    strict=True,               # Fail on non-existent terms (default)\n    cache_labels=True,         # Cache lookups to disk\n    cache_dir=\"cache\",\n    oak_config_path=\"oak_config.yaml\",\n)\n\n# Create validator\nvalidator = Validator(\n    schema=\"schema.yaml\",\n    validation_plugins=[plugin]\n)\n\n# Validate\nloader = YamlLoader(\"data.yaml\")\nreport = validator.validate_source(loader, target_class=\"GeneAnnotation\")\n\n# Check results\nif len(report.results) == 0:\n    print(\"Validation passed!\")\nelse:\n    for result in report.results:\n        print(f\"{result.severity.name}: {result.message}\")\n</code></pre>"},{"location":"howto-bindings/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"howto-bindings/#issue-term-not-found-for-valid-terms","title":"Issue: \"Term not found\" for valid terms","text":"<p>Cause: The prefix isn't configured in oak_config.yaml</p> <p>Solution: Add the prefix to your oak_config.yaml:</p> <pre><code>ontology_adapters:\n  GO: sqlite:obo:go  # Add this line\n</code></pre>"},{"location":"howto-bindings/#issue-dynamic-enum-expansion-is-slow","title":"Issue: Dynamic enum expansion is slow","text":"<p>Cause: Large ontologies take time to traverse</p> <p>Solutions: 1. Enable caching with <code>--cache-dir cache</code> 2. Use more specific source nodes (lower in the hierarchy) 3. Consider using a local sqlite database instead of downloading</p>"},{"location":"howto-bindings/#issue-unknown-prefix-warnings","title":"Issue: Unknown prefix warnings","text":"<p>Cause: Data contains prefixes not in your oak_config.yaml</p> <p>Solution: Either add the prefix to oak_config.yaml or ignore if expected:</p> <pre><code>ontology_adapters:\n  KNOWN_PREFIX: sqlite:obo:known\n  # Unknown prefixes will be skipped with a warning\n</code></pre>"},{"location":"howto-bindings/#validation-summary","title":"Validation Summary","text":"Validation Type What it Catches Flag Binding + Dynamic Enum Terms outside ontology branch (default) Strict Mode Fabricated/non-existent term IDs <code>--no-lenient</code> (default) Label Validation Mismatched labels <code>--labels</code>"},{"location":"howto-bindings/#next-steps","title":"Next Steps","text":"<ul> <li>Binding Validation Reference - Complete reference</li> <li>Bindings Explained - Conceptual overview</li> <li>Anti-Hallucination Guardrails - Using validation with AI</li> <li>Configuration - oak_config.yaml options</li> </ul>"},{"location":"ontologies-primer/","title":"Semantic Artefacts in LinkML: A Primer","text":"<p>This page introduces ontologies, vocabularies, and controlled value sets\u2014collectively called semantic artefacts\u2014and how they integrate with LinkML schemas for term validation.</p>"},{"location":"ontologies-primer/#what-are-semantic-artefacts","title":"What are Semantic Artefacts?","text":"<p>Semantic artefacts are structured collections of terms with formal definitions. They include:</p> <ul> <li>Ontologies - Rich hierarchical structures with relationships (Gene Ontology, SNOMED CT)</li> <li>Controlled vocabularies - Curated term lists with definitions (ISO codes, industry standards)</li> <li>Value sets - Enumerated lists of allowed values (status codes, categories)</li> <li>Code systems - Standardized identifier schemes (country codes, currency codes)</li> </ul> <p>All share a common pattern: terms with unique identifiers and human-readable labels.</p>"},{"location":"ontologies-primer/#why-validation-matters-the-opaque-id-problem","title":"Why Validation Matters: The Opaque ID Problem","text":"<p>Many standardized code systems use opaque identifiers\u2014codes that don't reveal their meaning:</p> System Code Meaning ISO 4217 (Currency) <code>CHF</code> Swiss Franc ISO 3166-1 (Country) <code>CHE</code> Switzerland NAICS (Industry) <code>5112</code> Software Publishers OMB Race/Ethnicity <code>2106-3</code> White Gene Ontology <code>GO:0007049</code> cell cycle ICD-10 <code>E11.9</code> Type 2 diabetes mellitus without complications <p>When IDs are opaque, you can't tell if data is correct by looking at it. Is <code>CHE</code> a country or currency? Is <code>5112</code> the right industry code? Without validation, errors slip through.</p> <p>This is where linkml-term-validator helps: it verifies that codes exist in their source vocabularies and that labels match.</p>"},{"location":"ontologies-primer/#anatomy-of-a-term","title":"Anatomy of a Term","text":"<p>Whether from an ontology or a simple code list, terms share common elements:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Term: GO:0007049                           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Label: cell cycle                          \u2502\n\u2502  Definition: The series of events by which  \u2502\n\u2502              a cell replicates...           \u2502\n\u2502  Synonyms: cell division cycle, CDC         \u2502\n\u2502  Parent: GO:0008150 (biological_process)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>For validation, the key properties are:</p> <ul> <li>Identifier (CURIE): Unique, stable reference</li> <li>Label: Canonical human-readable name</li> <li>Relationships: Hierarchy enabling \"is-a\" queries</li> </ul>"},{"location":"ontologies-primer/#curies-compact-identifiers","title":"CURIEs: Compact Identifiers","text":"<p>Terms are identified by CURIEs (Compact URIs):</p> <pre><code>GO:0008150\n\u2502   \u2514\u2500\u2500\u2500\u2500 Local identifier\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Prefix (namespace)\n</code></pre> <p>CURIEs expand to full URIs:</p> <ul> <li><code>GO:0008150</code> \u2192 <code>http://purl.obolibrary.org/obo/GO_0008150</code></li> <li><code>ISO4217:CHF</code> \u2192 (currency code for Swiss Franc)</li> <li><code>NAICS:5112</code> \u2192 (Software Publishers sector)</li> </ul> <p>LinkML schemas declare prefixes:</p> <pre><code>prefixes:\n  GO: http://purl.obolibrary.org/obo/GO_\n  ISO4217: https://example.org/iso4217/\n  NAICS: https://example.org/naics/\n</code></pre>"},{"location":"ontologies-primer/#examples-across-domains","title":"Examples Across Domains","text":""},{"location":"ontologies-primer/#life-sciences","title":"Life Sciences","text":"Vocabulary Prefix Domain Example Gene Ontology GO Biological processes <code>GO:0007049</code> (cell cycle) Cell Ontology CL Cell types <code>CL:0000540</code> (neuron) MONDO MONDO Diseases <code>MONDO:0004975</code> (Alzheimer disease) ChEBI CHEBI Chemicals <code>CHEBI:15377</code> (water)"},{"location":"ontologies-primer/#industry-standards","title":"Industry &amp; Standards","text":"Vocabulary Prefix Domain Example ISO 4217 ISO4217 Currency codes <code>CHF</code> (Swiss Franc) ISO 3166-1 ISO3166 Country codes <code>CHE</code> (Switzerland) NAICS NAICS Industry sectors <code>5112</code> (Software Publishers) OMB Categories OMB Race/ethnicity <code>2106-3</code> (White)"},{"location":"ontologies-primer/#environmental-materials","title":"Environmental &amp; Materials","text":"Vocabulary Prefix Domain Example ENVO ENVO Environments <code>ENVO:00000015</code> (ocean) ChEBI CHEBI Chemical elements <code>CHEBI:33256</code> (gallium) <p>See the LinkML Value Sets collection for many more examples.</p>"},{"location":"ontologies-primer/#the-data-consistency-problem","title":"The Data Consistency Problem","text":"<p>When collecting data across teams or systems, inconsistency creeps in:</p> <p>Without controlled vocabularies:</p> <pre><code># Team A\nlocation: \"ocean\"\n\n# Team B\nlocation: \"Ocean\"\n\n# Team C\nlocation: \"marine environment\"\n\n# Team D\nlocation: \"sea\"\n</code></pre> <p>With controlled vocabularies:</p> <pre><code># All teams use the same identifier\nlocation:\n  id: ENVO:00000015\n  label: ocean\n</code></pre> <p>Now data is:</p> <ul> <li>Consistent: Same concept, same ID</li> <li>Validatable: We can check <code>ENVO:00000015</code> exists</li> <li>Interoperable: Systems can exchange and merge data</li> <li>Queryable: Find all marine samples via hierarchy</li> </ul> <p>This pattern applies whether you're tracking environmental samples, financial transactions, or patient diagnoses.</p>"},{"location":"ontologies-primer/#hierarchical-queries","title":"Hierarchical Queries","text":"<p>Many semantic artefacts organize terms hierarchically:</p> <pre><code>ENVO:00000015 (ocean)\n\u251c\u2500\u2500 ENVO:00000016 (sea)\n\u251c\u2500\u2500 ENVO:01000023 (coastal ocean)\n\u2514\u2500\u2500 ENVO:01000024 (deep ocean)\n    \u251c\u2500\u2500 ENVO:01000025 (hadal zone)\n    \u2514\u2500\u2500 ENVO:01000026 (abyssal zone)\n</code></pre> <p>This enables powerful queries:</p> <ul> <li>\"All ocean environments\" = <code>ENVO:00000015</code> and all its descendants</li> <li>Dynamic enums can express this: \"any subtype of ocean\"</li> </ul>"},{"location":"ontologies-primer/#linkml-integration-patterns","title":"LinkML Integration Patterns","text":""},{"location":"ontologies-primer/#1-static-enum-meanings","title":"1. Static Enum Meanings","text":"<p>Map your codes to authoritative terms:</p> <pre><code>enums:\n  CurrencyEnum:\n    permissible_values:\n      USD:\n        meaning: ISO4217:USD\n        title: US Dollar\n      EUR:\n        meaning: ISO4217:EUR\n        title: Euro\n      CHF:\n        meaning: ISO4217:CHF\n        title: Swiss Franc\n</code></pre>"},{"location":"ontologies-primer/#2-dynamic-enums","title":"2. Dynamic Enums","text":"<p>Query a vocabulary for allowed values:</p> <pre><code>enums:\n  OceanEnvironmentEnum:\n    reachable_from:\n      source_ontology: obo:envo\n      source_nodes:\n        - ENVO:00000015  # ocean\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre>"},{"location":"ontologies-primer/#3-bindings-on-complex-objects","title":"3. Bindings on Complex Objects","text":"<p>Constrain fields within nested structures:</p> <pre><code>classes:\n  Sample:\n    attributes:\n      environment:\n        range: EnvironmentTerm\n        bindings:\n          - binds_value_of: id\n            range: OceanEnvironmentEnum\n</code></pre>"},{"location":"ontologies-primer/#see-also","title":"See Also","text":"<ul> <li>Enumerations in LinkML - Static and dynamic enums</li> <li>Bindings Explained - Complex object constraints</li> <li>Ontology Access - OAK configuration details</li> </ul>"},{"location":"ontologies-primer/#external-resources","title":"External Resources","text":"<ul> <li>LinkML Value Sets - Collection of commonly used value sets</li> <li>LinkML Helps with Ontology Use - OBO Academy tutorial</li> <li>LinkML Semantic Enumerations - Official documentation</li> <li>OBO Foundry - Open biomedical ontologies</li> <li>Ontology Lookup Service - Search ontologies online</li> </ul>"},{"location":"ontology-access/","title":"Ontology Access","text":"<p>All linkml-term-validator plugins use OAK (Ontology Access Kit) to access ontology data.</p>"},{"location":"ontology-access/#oak-adapters","title":"OAK Adapters","text":"<p>An adapter is OAK's abstraction for accessing ontology sources. Different adapters support different backends:</p> <ul> <li><code>sqlite:obo:</code> - Pre-downloaded OBO ontologies in SQLite format (default, fast, offline)</li> <li><code>simpleobo:</code> - Simple local OBO files (good for unit tests)</li> <li><code>ols:</code> - Ontology Lookup Service (online, no local download required)</li> <li><code>bioportal:</code> - NCBO BioPortal (requires API key)</li> <li><code>ubergraph:</code> - Ubergraph SPARQL endpoint</li> </ul>"},{"location":"ontology-access/#default-behavior","title":"Default Behavior","text":"<p>Without configuration, the validator uses <code>sqlite:obo:</code> as the default adapter, which automatically creates per-prefix adapters:</p> <ul> <li><code>GO:0008150</code> \u2192 uses <code>sqlite:obo:go</code></li> <li><code>CHEBI:15377</code> \u2192 uses <code>sqlite:obo:chebi</code></li> <li><code>UBERON:0000468</code> \u2192 uses <code>sqlite:obo:uberon</code></li> </ul> <p>This works for any OBO ontology that has been downloaded via OAK.</p>"},{"location":"ontology-access/#per-prefix-configuration","title":"Per-Prefix Configuration","text":"<p>You can override the adapter for specific prefixes using an <code>oak_config.yaml</code> file:</p> <pre><code>ontology_adapters:\n  GO: sqlite:obo:go           # Use local GO database\n  CHEBI: ols:                 # Use OLS for CHEBI\n  MY_CUSTOM: simpleobo:my_ontology.obo  # Use local OBO file\n  SKIP_THIS: \"\"               # Skip validation for this prefix\n</code></pre> <p>Important: When using <code>oak_config.yaml</code>, ONLY the prefixes listed in the config will be validated. Unlisted prefixes are reported as \"unknown.\"</p>"},{"location":"ontology-access/#using-the-config-file","title":"Using the Config File","text":"<p>CLI:</p> <pre><code>linkml-term-validator validate-schema --config oak_config.yaml schema.yaml\nlinkml-term-validator validate-data --config oak_config.yaml data.yaml --schema schema.yaml\n</code></pre> <p>Python API:</p> <pre><code>from linkml_term_validator.plugins import PermissibleValueMeaningPlugin\n\nplugin = PermissibleValueMeaningPlugin(oak_config_path=\"oak_config.yaml\")\n</code></pre>"},{"location":"ontology-access/#adapter-details","title":"Adapter Details","text":""},{"location":"ontology-access/#sqliteobo-recommended","title":"sqlite:obo: (Recommended)","text":"<p>Uses pre-downloaded OBO ontologies in SQLite format.</p> <p>Pros: - Fast queries (SQLite is efficient) - Works offline after initial download - No rate limiting - Consistent results</p> <p>Cons: - Requires initial download - Takes disk space (~100MB-1GB per ontology) - Need to manually update for latest ontology versions</p> <p>First-time setup:</p> <p>The first time you validate with a new ontology, OAK will download and build the SQLite database. This can take a few minutes but only happens once.</p>"},{"location":"ontology-access/#simpleobo","title":"simpleobo:","text":"<p>Uses local OBO files directly. Ideal for unit tests and custom ontologies.</p> <p>Usage:</p> <pre><code>ontology_adapters:\n  MY_CUSTOM: simpleobo:path/to/my_ontology.obo\n  TEST: simpleobo:tests/data/test_ontology.obo\n</code></pre> <p>Pros: - Fast, lightweight - Perfect for testing - No network access required - Full control over ontology version</p> <p>Cons: - Limited query capabilities compared to SQLite - Only works with OBO format - Need to manage OBO files yourself</p>"},{"location":"ontology-access/#ols","title":"ols:","text":"<p>Uses the Ontology Lookup Service (EBI). Online service, no local downloads.</p> <p>Usage:</p> <pre><code>ontology_adapters:\n  GO: ols:\n  CHEBI: ols:\n</code></pre> <p>Pros: - No local downloads - Always uses latest ontology versions - Works out-of-the-box</p> <p>Cons: - Requires internet connection - Slower than local adapters - Subject to rate limiting - Service availability dependence</p>"},{"location":"ontology-access/#bioportal","title":"bioportal:","text":"<p>Uses NCBO BioPortal. Requires API key.</p> <p>Setup:</p> <p>Set <code>BIOPORTAL_API_KEY</code> environment variable:</p> <pre><code>export BIOPORTAL_API_KEY=your-api-key-here\nlinkml-term-validator validate-schema --config oak_config.yaml schema.yaml\n</code></pre> <p>Usage:</p> <pre><code>ontology_adapters:\n  GO: bioportal:\n  CHEBI: bioportal:\n</code></pre>"},{"location":"ontology-access/#unknown-prefixes","title":"Unknown Prefixes","text":"<p>When the validator encounters a prefix it doesn't recognize (not in <code>oak_config.yaml</code> or not a known OBO ontology), it:</p> <ol> <li>Logs a warning</li> <li>Skips validation for that term</li> <li>Reports unknown prefixes at the end of validation</li> </ol> <p>Example output:</p> <pre><code>\u26a0\ufe0f  Unknown prefixes encountered (validation skipped):\n  - MY_CUSTOM\n  - INTERNAL\n\nConsider adding these to oak_config.yaml to enable validation.\n</code></pre> <p>To fix: Add them to your <code>oak_config.yaml</code>:</p> <pre><code>ontology_adapters:\n  MY_CUSTOM: simpleobo:path/to/ontology.obo\n  INTERNAL: \"\"  # Or empty string to explicitly skip\n</code></pre>"},{"location":"ontology-access/#see-also","title":"See Also","text":"<ul> <li>Configuration - Complete configuration guide</li> <li>Caching - How ontology data is cached</li> <li>Validation Types - Understanding the validation plugins</li> </ul>"},{"location":"plugin-reference/","title":"Plugin Reference","text":"<p>This page provides complete API reference documentation for the three LinkML ValidationPlugin implementations provided by linkml-term-validator.</p> <p>All plugins are designed to work with the LinkML Validator framework and can be used standalone or composed together.</p>"},{"location":"plugin-reference/#permissiblevaluemeaningplugin","title":"PermissibleValueMeaningPlugin","text":"<p>Validates that <code>meaning</code> fields in enum permissible values reference valid ontology terms with correct labels.</p> <p>Module: <code>linkml_term_validator.plugins.permissible_value_meaning_plugin</code></p>"},{"location":"plugin-reference/#constructor","title":"Constructor","text":"<pre><code>from linkml_term_validator.plugins import PermissibleValueMeaningPlugin\n\nplugin = PermissibleValueMeaningPlugin(\n    oak_adapter_string=\"sqlite:obo:\",\n    oak_config_path=None,\n    strict_mode=False,\n    cache_labels=True,\n    cache_dir=\"cache\",\n)\n</code></pre>"},{"location":"plugin-reference/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>oak_adapter_string</code> <code>str</code> <code>\"sqlite:obo:\"</code> Default OAK adapter string for ontology access <code>oak_config_path</code> <code>str \\| None</code> <code>None</code> Path to <code>oak_config.yaml</code> for per-prefix adapter configuration <code>strict_mode</code> <code>bool</code> <code>False</code> If <code>True</code>, treat all warnings as errors <code>cache_labels</code> <code>bool</code> <code>True</code> Enable file-based caching of ontology labels <code>cache_dir</code> <code>str</code> <code>\"cache\"</code> Directory for cache files"},{"location":"plugin-reference/#usage","title":"Usage","text":"<p>Basic usage:</p> <pre><code>from linkml.validator import Validator\nfrom linkml_term_validator.plugins import PermissibleValueMeaningPlugin\n\n# Create plugin\nplugin = PermissibleValueMeaningPlugin()\n\n# Create validator with plugin\nvalidator = Validator(\n    schema=\"schema.yaml\",\n    validation_plugins=[plugin]\n)\n\n# Validate schema file\nreport = validator.validate_file(\"schema.yaml\")\n\n# Check results\nif len(report.results) == 0:\n    print(\"\u2705 All permissible values validated successfully\")\nelse:\n    for result in report.results:\n        print(f\"{result.severity.name}: {result.message}\")\n</code></pre> <p>With custom configuration:</p> <pre><code>plugin = PermissibleValueMeaningPlugin(\n    oak_config_path=\"oak_config.yaml\",\n    strict_mode=True,\n    cache_dir=\"custom_cache\"\n)\n</code></pre> <p>With OLS adapter:</p> <pre><code>plugin = PermissibleValueMeaningPlugin(\n    oak_adapter_string=\"ols:\",\n    cache_labels=False  # Don't cache when using online service\n)\n</code></pre>"},{"location":"plugin-reference/#what-it-validates","title":"What It Validates","text":"<p>For each enum in the schema:</p> <ol> <li>Extracts all permissible values with <code>meaning</code> fields</li> <li>For each meaning CURIE (e.g., <code>GO:0008150</code>):</li> <li>Retrieves the canonical label from the ontology</li> <li>Compares against expected labels from the schema</li> <li>Reports mismatches or missing terms</li> </ol> <p>Expected labels are derived from:</p> <ul> <li>Permissible value name (e.g., <code>BIOLOGICAL_PROCESS</code>)</li> <li><code>title</code> field</li> <li><code>description</code> field</li> <li><code>aliases</code> list</li> <li>Annotation values for tags like <code>label</code>, <code>display_name</code>, <code>synonym</code></li> </ul>"},{"location":"plugin-reference/#validation-results","title":"Validation Results","text":"<p>Results use LinkML's <code>ValidationResult</code> class with the following severity levels:</p> Severity Condition <code>ERROR</code> Label mismatch for configured prefix (or any prefix in strict mode) <code>WARN</code> Label mismatch for unconfigured prefix (non-strict mode) <code>INFO</code> Missing term from unconfigured prefix"},{"location":"plugin-reference/#example","title":"Example","text":"<p>Schema:</p> <pre><code>enums:\n  BiologicalProcessEnum:\n    permissible_values:\n      BIOLOGICAL_PROCESS:\n        title: biological process\n        meaning: GO:0008150\n      CELL_CYCLE:\n        title: cell cycle\n        meaning: GO:0007049\n</code></pre> <p>Code:</p> <pre><code>from linkml.validator import Validator\nfrom linkml_term_validator.plugins import PermissibleValueMeaningPlugin\n\nplugin = PermissibleValueMeaningPlugin()\nvalidator = Validator(schema=\"schema.yaml\", validation_plugins=[plugin])\nreport = validator.validate_file(\"schema.yaml\")\n\nprint(f\"Validated {len(report.results)} permissible values\")\n</code></pre>"},{"location":"plugin-reference/#dynamicenumplugin","title":"DynamicEnumPlugin","text":"<p>Validates data values against dynamic enum constraints defined via <code>reachable_from</code>, <code>matches</code>, or <code>concepts</code>.</p> <p>Module: <code>linkml_term_validator.plugins.dynamic_enum_plugin</code></p>"},{"location":"plugin-reference/#constructor_1","title":"Constructor","text":"<pre><code>from linkml_term_validator.plugins import DynamicEnumPlugin\n\nplugin = DynamicEnumPlugin(\n    oak_adapter_string=\"sqlite:obo:\",\n    oak_config_path=None,\n    cache_labels=True,\n    cache_dir=\"cache\",\n)\n</code></pre>"},{"location":"plugin-reference/#parameters_1","title":"Parameters","text":"Parameter Type Default Description <code>oak_adapter_string</code> <code>str</code> <code>\"sqlite:obo:\"</code> Default OAK adapter string for ontology access <code>oak_config_path</code> <code>str \\| None</code> <code>None</code> Path to <code>oak_config.yaml</code> for per-prefix adapter configuration <code>cache_labels</code> <code>bool</code> <code>True</code> Enable file-based caching of ontology labels <code>cache_dir</code> <code>str</code> <code>\"cache\"</code> Directory for cache files"},{"location":"plugin-reference/#usage_1","title":"Usage","text":"<p>Basic usage:</p> <pre><code>from linkml.validator import Validator\nfrom linkml_term_validator.plugins import DynamicEnumPlugin\n\n# Create plugin\nplugin = DynamicEnumPlugin()\n\n# Create validator\nvalidator = Validator(\n    schema=\"schema.yaml\",\n    validation_plugins=[plugin]\n)\n\n# Validate data file\nreport = validator.validate_file(\"data.yaml\")\n\n# Check results\nif len(report.results) == 0:\n    print(\"\u2705 All dynamic enum constraints satisfied\")\nelse:\n    for result in report.results:\n        print(f\"{result.severity.name}: {result.message}\")\n</code></pre> <p>With YamlLoader (recommended for YAML data):</p> <pre><code>from linkml.validator import Validator\nfrom linkml_runtime.loaders import yaml_loader\nfrom linkml_term_validator.plugins import DynamicEnumPlugin\n\nplugin = DynamicEnumPlugin()\nvalidator = Validator(schema=\"schema.yaml\", validation_plugins=[plugin])\n\nloader = yaml_loader.YamlLoader()\nreport = validator.validate_source(loader, \"data.yaml\", target_class=\"Person\")\n</code></pre>"},{"location":"plugin-reference/#what-it-validates_1","title":"What It Validates","text":"<p>For each slot in the data with a dynamic enum range:</p> <ol> <li>Checks if the value satisfies the enum constraint</li> <li>For <code>reachable_from</code>: validates value is a descendant of source nodes</li> <li>For <code>matches</code>: validates value matches the specified pattern</li> <li>For <code>concepts</code>: validates value is one of the specified concepts</li> </ol> <p>Important semantics:</p> <ul> <li>For <code>reachable_from</code>, source nodes themselves are EXCLUDED by default</li> <li>Only descendants (via specified relationship types) are included</li> </ul>"},{"location":"plugin-reference/#validation-results_1","title":"Validation Results","text":"Severity Condition <code>ERROR</code> Value does not satisfy dynamic enum constraint"},{"location":"plugin-reference/#example_1","title":"Example","text":"<p>Schema:</p> <pre><code>classes:\n  Neuron:\n    attributes:\n      cell_type:\n        range: NeuronTypeEnum\n\nenums:\n  NeuronTypeEnum:\n    reachable_from:\n      source_ontology: sqlite:obo:cl\n      source_nodes:\n        - CL:0000540  # neuron\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre> <p>Data:</p> <pre><code>neurons:\n  - cell_type: CL:0000100  # Valid - descendant of CL:0000540\n  - cell_type: GO:0008150  # INVALID - not a neuron type\n</code></pre> <p>Code:</p> <pre><code>from linkml.validator import Validator\nfrom linkml_runtime.loaders import yaml_loader\nfrom linkml_term_validator.plugins import DynamicEnumPlugin\n\nplugin = DynamicEnumPlugin()\nvalidator = Validator(schema=\"schema.yaml\", validation_plugins=[plugin])\n\nloader = yaml_loader.YamlLoader()\nreport = validator.validate_source(loader, \"neurons.yaml\", target_class=\"Neuron\")\n\n# Will show ERROR for GO:0008150\nfor result in report.results:\n    print(f\"{result.severity.name}: {result.message}\")\n</code></pre>"},{"location":"plugin-reference/#bindingvalidationplugin","title":"BindingValidationPlugin","text":"<p>Validates that nested object fields satisfy binding range constraints, optionally checking labels match ontology.</p> <p>Module: <code>linkml_term_validator.plugins.binding_validation_plugin</code></p>"},{"location":"plugin-reference/#constructor_2","title":"Constructor","text":"<pre><code>from linkml_term_validator.plugins import BindingValidationPlugin\n\nplugin = BindingValidationPlugin(\n    oak_adapter_string=\"sqlite:obo:\",\n    oak_config_path=None,\n    validate_labels=False,\n    cache_labels=True,\n    cache_dir=\"cache\",\n)\n</code></pre>"},{"location":"plugin-reference/#parameters_2","title":"Parameters","text":"Parameter Type Default Description <code>oak_adapter_string</code> <code>str</code> <code>\"sqlite:obo:\"</code> Default OAK adapter string for ontology access <code>oak_config_path</code> <code>str \\| None</code> <code>None</code> Path to <code>oak_config.yaml</code> for per-prefix adapter configuration <code>validate_labels</code> <code>bool</code> <code>False</code> If <code>True</code>, also validate that labels match ontology canonical labels <code>cache_labels</code> <code>bool</code> <code>True</code> Enable file-based caching of ontology labels <code>cache_dir</code> <code>str</code> <code>\"cache\"</code> Directory for cache files"},{"location":"plugin-reference/#usage_2","title":"Usage","text":"<p>Basic usage (binding validation only):</p> <pre><code>from linkml.validator import Validator\nfrom linkml_term_validator.plugins import BindingValidationPlugin\n\n# Create plugin without label validation\nplugin = BindingValidationPlugin()\n\nvalidator = Validator(\n    schema=\"schema.yaml\",\n    validation_plugins=[plugin]\n)\n\nreport = validator.validate_file(\"data.yaml\")\n</code></pre> <p>With label validation (anti-hallucination mode):</p> <pre><code># Enable label validation for AI-generated data\nplugin = BindingValidationPlugin(validate_labels=True)\n\nvalidator = Validator(schema=\"schema.yaml\", validation_plugins=[plugin])\nreport = validator.validate_file(\"ai_generated_data.yaml\")\n\n# Will catch both binding violations AND label mismatches\nfor result in report.results:\n    print(f\"{result.severity.name}: {result.message}\")\n</code></pre> <p>With custom configuration:</p> <pre><code>plugin = BindingValidationPlugin(\n    oak_config_path=\"oak_config.yaml\",\n    validate_labels=True,\n    cache_dir=\"custom_cache\"\n)\n</code></pre>"},{"location":"plugin-reference/#what-it-validates_2","title":"What It Validates","text":"<p>For each slot with binding constraints:</p> <ol> <li>Binding constraint validation (always):</li> <li>Checks that the value in the nested object's field satisfies the binding's range constraint</li> <li> <p>Range is typically a dynamic enum (e.g., only biological processes, only neuron types)</p> </li> <li> <p>Label validation (if <code>validate_labels=True</code>):</p> </li> <li>Detects label fields via <code>slot.implements</code> (e.g., <code>implements: [rdfs:label]</code>)</li> <li>Falls back to convention (field named <code>label</code>) if no <code>implements</code> declared</li> <li>Retrieves the canonical label from the ontology</li> <li>Compares against the label provided in the data</li> <li>Reports mismatches</li> </ol>"},{"location":"plugin-reference/#nested-structure-support","title":"Nested Structure Support","text":"<p>The plugin recursively validates bindings at all nesting levels, not just the top-level target class. This is essential for schemas using the common patterns:</p> <ul> <li>Descriptor pattern: Wrapper objects with ontology term references</li> <li>Annotation pattern: Annotations with bound term fields</li> <li>Deeply nested structures: e.g., <code>Disease \u2192 Pathophysiology \u2192 CellTypes \u2192 Term</code></li> </ul> <p>Example nested schema:</p> <pre><code>classes:\n  Disease:\n    attributes:\n      disease_term:\n        range: DiseaseDescriptor\n        inlined: true\n      pathophysiology:\n        range: Pathophysiology\n        multivalued: true\n        inlined_as_list: true\n\n  Pathophysiology:\n    attributes:\n      cell_types:\n        range: CellTypeDescriptor\n        multivalued: true\n        inlined_as_list: true\n\n  DiseaseDescriptor:\n    attributes:\n      term:\n        range: Term\n        bindings:\n          - binds_value_of: id\n            range: DiseaseTermEnum  # \u2190 Validated!\n\n  CellTypeDescriptor:\n    attributes:\n      term:\n        range: Term\n        bindings:\n          - binds_value_of: id\n            range: CellTypeEnum  # \u2190 Also validated!\n</code></pre> <p>Error messages include the full JSON path to the violation:</p> <pre><code>\u274c ERROR: Value 'CL:9999999' not in enum 'CellTypeEnum'\n    path: pathophysiology[0].cell_types[1].term\n    slot: term\n    field: id\n</code></pre>"},{"location":"plugin-reference/#validation-results_2","title":"Validation Results","text":"Severity Condition <code>ERROR</code> Binding constraint violated <code>ERROR</code> Label mismatch (if <code>validate_labels=True</code>) <code>WARN</code> Label mismatch for unconfigured prefix (if <code>validate_labels=True</code>)"},{"location":"plugin-reference/#example_2","title":"Example","text":"<p>Schema:</p> <pre><code>prefixes:\n  rdfs: http://www.w3.org/2000/01/rdf-schema#\n\nclasses:\n  GeneAnnotation:\n    attributes:\n      gene:\n        range: string\n      go_term:\n        range: GOTerm\n        bindings:\n          - binds_value_of: id\n            range: BiologicalProcessEnum\n\n  GOTerm:\n    attributes:\n      id:\n        range: string\n      label:\n        range: string\n        implements:\n          - rdfs:label  # Explicit label field declaration\n\nenums:\n  BiologicalProcessEnum:\n    reachable_from:\n      source_ontology: sqlite:obo:go\n      source_nodes:\n        - GO:0008150  # biological_process\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre> <p>Data:</p> <pre><code>annotations:\n  - gene: BRCA1\n    go_term:\n      id: GO:0007049  # Valid - is a biological process\n      label: cell cycle\n  - gene: EGFR\n    go_term:\n      id: GO:0005575  # INVALID - cellular_component, not a process\n      label: cellular_component\n</code></pre> <p>Code:</p> <pre><code>from linkml.validator import Validator\nfrom linkml_runtime.loaders import yaml_loader\nfrom linkml_term_validator.plugins import BindingValidationPlugin\n\n# With label validation enabled\nplugin = BindingValidationPlugin(validate_labels=True)\nvalidator = Validator(schema=\"schema.yaml\", validation_plugins=[plugin])\n\nloader = yaml_loader.YamlLoader()\nreport = validator.validate_source(\n    loader,\n    \"annotations.yaml\",\n    target_class=\"GeneAnnotation\"\n)\n\n# Will show ERROR for GO:0005575 (wrong category)\n# Will also validate that labels match ontology\nfor result in report.results:\n    print(f\"{result.severity.name}: {result.message}\")\n</code></pre>"},{"location":"plugin-reference/#composing-multiple-plugins","title":"Composing Multiple Plugins","text":"<p>You can use multiple plugins together for comprehensive validation:</p> <pre><code>from linkml.validator import Validator\nfrom linkml.validator.plugins import JsonschemaValidationPlugin\nfrom linkml_term_validator.plugins import (\n    DynamicEnumPlugin,\n    BindingValidationPlugin,\n)\n\n# Build validation pipeline\nplugins = [\n    JsonschemaValidationPlugin(closed=True),  # Structural validation\n    DynamicEnumPlugin(),                       # Dynamic enum validation\n    BindingValidationPlugin(validate_labels=True),  # Binding + label validation\n]\n\n# Create validator with all plugins\nvalidator = Validator(\n    schema=\"schema.yaml\",\n    validation_plugins=plugins\n)\n\n# Validate data\nreport = validator.validate_file(\"data.yaml\")\n\n# Check results\nif len(report.results) == 0:\n    print(\"\u2705 All validations passed\")\nelse:\n    # Group results by severity\n    errors = [r for r in report.results if r.severity.name == \"ERROR\"]\n    warnings = [r for r in report.results if r.severity.name == \"WARN\"]\n\n    print(f\"Errors: {len(errors)}\")\n    print(f\"Warnings: {len(warnings)}\")\n\n    for result in report.results:\n        print(f\"{result.severity.name}: {result.message}\")\n</code></pre>"},{"location":"plugin-reference/#integration-with-linkml-validate","title":"Integration with linkml-validate","text":"<p>All plugins can be used with the standard <code>linkml-validate</code> command via configuration files.</p> <p>Configuration file:</p> <pre><code># validation_config.yaml\nschema: schema.yaml\ntarget_class: Person\n\ndata_sources:\n  - data.yaml\n\nplugins:\n  # Standard LinkML validation\n  JsonschemaValidationPlugin:\n    closed: true\n\n  # Dynamic enum validation\n  \"linkml_term_validator.plugins.DynamicEnumPlugin\":\n    oak_adapter_string: \"sqlite:obo:\"\n    cache_labels: true\n    cache_dir: cache\n\n  # Binding validation with label checking\n  \"linkml_term_validator.plugins.BindingValidationPlugin\":\n    oak_adapter_string: \"sqlite:obo:\"\n    validate_labels: true\n    cache_labels: true\n    cache_dir: cache\n</code></pre> <p>Run validation:</p> <pre><code>linkml-validate --config validation_config.yaml\n</code></pre>"},{"location":"plugin-reference/#advanced-usage","title":"Advanced Usage","text":""},{"location":"plugin-reference/#custom-validation-workflow","title":"Custom Validation Workflow","text":"<pre><code>from linkml.validator import Validator\nfrom linkml_runtime.loaders import yaml_loader\nfrom linkml_term_validator.plugins import (\n    DynamicEnumPlugin,\n    BindingValidationPlugin,\n)\n\n# Build custom validation pipeline\ndef validate_ai_generated_data(data_path, schema_path):\n    \"\"\"Validate AI-generated data with anti-hallucination checks.\"\"\"\n\n    plugins = [\n        DynamicEnumPlugin(oak_adapter_string=\"sqlite:obo:\"),\n        BindingValidationPlugin(\n            validate_labels=True,  # Enable label checking\n            oak_adapter_string=\"sqlite:obo:\"\n        ),\n    ]\n\n    validator = Validator(schema=schema_path, validation_plugins=plugins)\n    loader = yaml_loader.YamlLoader()\n\n    report = validator.validate_source(\n        loader,\n        data_path,\n        target_class=\"GeneAnnotation\"\n    )\n\n    # Fail fast on any errors\n    if len(report.results) &gt; 0:\n        errors = [r for r in report.results if r.severity.name == \"ERROR\"]\n        if errors:\n            raise ValueError(f\"Validation failed with {len(errors)} error(s)\")\n\n    return report\n\n# Use in AI pipeline\ntry:\n    report = validate_ai_generated_data(\n        \"ai_output.yaml\",\n        \"schema.yaml\"\n    )\n    print(\"\u2705 AI-generated data validated successfully\")\nexcept ValueError as e:\n    print(f\"\u274c {e}\")\n    # Retry AI generation or fail\n</code></pre>"},{"location":"plugin-reference/#accessing-validator-state","title":"Accessing Validator State","text":"<pre><code>from linkml_term_validator.plugins import DynamicEnumPlugin\n\nplugin = DynamicEnumPlugin()\n\n# Access the OAK validator (for advanced use cases)\noak_validator = plugin.get_validator()\n\n# Check unknown prefixes encountered during validation\nunknown_prefixes = oak_validator.get_unknown_prefixes()\nif unknown_prefixes:\n    print(\"Unknown prefixes encountered:\")\n    for prefix in unknown_prefixes:\n        print(f\"  - {prefix}\")\n</code></pre>"},{"location":"plugin-reference/#testing-plugins","title":"Testing Plugins","text":"<pre><code>import pytest\nfrom linkml.validator import Validator\nfrom linkml_term_validator.plugins import DynamicEnumPlugin\n\ndef test_dynamic_enum_validation():\n    \"\"\"Test dynamic enum validation with local OBO file.\"\"\"\n\n    plugin = DynamicEnumPlugin(\n        oak_config_path=\"tests/data/test_oak_config.yaml\"\n    )\n\n    validator = Validator(\n        schema=\"tests/data/dynamic_enum_schema.yaml\",\n        validation_plugins=[plugin]\n    )\n\n    report = validator.validate_file(\"tests/data/valid_data.yaml\")\n\n    # Should have no errors\n    assert len(report.results) == 0\n\ndef test_invalid_dynamic_enum():\n    \"\"\"Test that invalid values are caught.\"\"\"\n\n    plugin = DynamicEnumPlugin(\n        oak_config_path=\"tests/data/test_oak_config.yaml\"\n    )\n\n    validator = Validator(\n        schema=\"tests/data/dynamic_enum_schema.yaml\",\n        validation_plugins=[plugin]\n    )\n\n    report = validator.validate_file(\"tests/data/invalid_data.yaml\")\n\n    # Should have errors\n    errors = [r for r in report.results if r.severity.name == \"ERROR\"]\n    assert len(errors) &gt; 0\n</code></pre>"},{"location":"plugin-reference/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Command-line usage</li> <li>Configuration - Configuring OAK adapters</li> <li>Validation Types - Understanding validation types</li> <li>Anti-Hallucination Guardrails - Preventing AI hallucinations</li> <li>Tutorials - Interactive Python API tutorial</li> </ul>"},{"location":"schema-validation/","title":"Schema Validation Reference","text":"<p>This reference covers validation of permissible value meanings in LinkML schemas\u2014ensuring that <code>meaning</code> CURIEs in static enums reference valid ontology terms with correct labels.</p>"},{"location":"schema-validation/#overview","title":"Overview","text":"<p>Schema validation uses the PermissibleValueMeaningPlugin to validate that:</p> <ol> <li>Each <code>meaning</code> CURIE exists in the source ontology</li> <li>The canonical label matches an expected label from the schema</li> </ol> <p>This is performed at schema authoring time, not data validation time.</p>"},{"location":"schema-validation/#cli-usage","title":"CLI Usage","text":"<pre><code># Basic schema validation\nlinkml-term-validator validate-schema schema.yaml\n\n# With strict mode (treat warnings as errors)\nlinkml-term-validator validate-schema --strict schema.yaml\n\n# With custom OAK configuration\nlinkml-term-validator validate-schema --oak-config oak_config.yaml schema.yaml\n\n# With OLS adapter (online lookup)\nlinkml-term-validator validate-schema --oak-adapter \"ols:\" schema.yaml\n</code></pre>"},{"location":"schema-validation/#cli-options","title":"CLI Options","text":"Option Description <code>--strict</code> Treat warnings as errors <code>--oak-adapter</code> OAK adapter string (default: <code>sqlite:obo:</code>) <code>--oak-config</code> Path to OAK configuration file <code>--cache-dir</code> Directory for cache files (default: <code>cache</code>) <code>--verbose</code> / <code>-v</code> Enable verbose output"},{"location":"schema-validation/#what-gets-validated","title":"What Gets Validated","text":""},{"location":"schema-validation/#permissible-value-structure","title":"Permissible Value Structure","text":"<p>For each enum in the schema with permissible values containing <code>meaning</code> fields:</p> <pre><code>enums:\n  BiologicalProcessEnum:\n    permissible_values:\n      CELL_CYCLE:\n        title: cell cycle           # \u2190 Expected label source\n        meaning: GO:0007049         # \u2190 CURIE to validate\n      DNA_REPLICATION:\n        title: DNA replication\n        meaning: GO:0006260\n        aliases:\n          - DNA synthesis           # \u2190 Alternative expected labels\n</code></pre>"},{"location":"schema-validation/#validation-steps","title":"Validation Steps","text":"<ol> <li>Term Existence: The CURIE (e.g., <code>GO:0007049</code>) is looked up in the ontology</li> <li>Label Retrieval: The canonical label is retrieved from the ontology</li> <li>Label Matching: The canonical label is compared against expected labels</li> </ol>"},{"location":"schema-validation/#expected-label-sources","title":"Expected Label Sources","text":"<p>The validator checks the canonical label against multiple sources (in order):</p> <ol> <li>Permissible value name (e.g., <code>CELL_CYCLE</code> \u2192 normalized to \"cell cycle\")</li> <li><code>title</code> field (e.g., <code>title: cell cycle</code>)</li> <li><code>description</code> field</li> <li><code>aliases</code> list (e.g., <code>aliases: [DNA synthesis, DNA synth]</code>)</li> <li>Annotation values for tags: <code>label</code>, <code>display_name</code>, <code>synonym</code></li> </ol>"},{"location":"schema-validation/#label-normalization","title":"Label Normalization","text":"<p>Before comparison, labels are normalized:</p> <ul> <li>Lowercased</li> <li>Underscores converted to spaces</li> <li>Multiple whitespace collapsed to single space</li> <li>Leading/trailing whitespace trimmed</li> </ul> <p>This means <code>BIOLOGICAL_PROCESS</code>, <code>biological process</code>, and <code>Biological Process</code> all match.</p>"},{"location":"schema-validation/#severity-levels","title":"Severity Levels","text":"Severity Condition ERROR Label mismatch for a configured prefix (in strict mode: any prefix) ERROR Term does not exist in a configured ontology WARN Label mismatch for an unconfigured prefix INFO Unconfigured prefix encountered"},{"location":"schema-validation/#configured-vs-unconfigured-prefixes","title":"Configured vs Unconfigured Prefixes","text":"<p>A configured prefix is one explicitly mapped in your <code>oak_config.yaml</code>:</p> <pre><code># oak_config.yaml\nontology_adapters:\n  GO: sqlite:obo:go    # GO is configured\n  CL: sqlite:obo:cl    # CL is configured\n  # HP is NOT configured - will use default adapter\n</code></pre> <p>Errors for configured prefixes are always raised. For unconfigured prefixes, mismatches are warnings (unless <code>--strict</code> is used).</p>"},{"location":"schema-validation/#examples","title":"Examples","text":""},{"location":"schema-validation/#basic-schema","title":"Basic Schema","text":"<pre><code>id: https://example.org/my-schema\nname: my-schema\nprefixes:\n  GO: http://purl.obolibrary.org/obo/GO_\n  linkml: https://w3id.org/linkml/\n\nenums:\n  ProcessEnum:\n    permissible_values:\n      CELL_CYCLE:\n        title: cell cycle\n        meaning: GO:0007049\n      APOPTOSIS:\n        title: apoptotic process\n        meaning: GO:0006915\n</code></pre> <p>Validation:</p> <pre><code>linkml-term-validator validate-schema schema.yaml\n</code></pre> <p>Output (valid):</p> <pre><code>\u2705 Validated 2 permissible value meanings\n</code></pre>"},{"location":"schema-validation/#schema-with-error","title":"Schema with Error","text":"<pre><code>enums:\n  ProcessEnum:\n    permissible_values:\n      WRONG_LABEL:\n        title: wrong label here     # This won't match!\n        meaning: GO:0007049         # Canonical label is \"cell cycle\"\n</code></pre> <p>Output:</p> <pre><code>\u274c ERROR: Label mismatch for GO:0007049\n   Expected: \"wrong label here\"\n   Found: \"cell cycle\"\n   Permissible value: WRONG_LABEL\n</code></pre>"},{"location":"schema-validation/#schema-with-aliases","title":"Schema with Aliases","text":"<p>Use aliases when your preferred name differs from the ontology label:</p> <pre><code>enums:\n  ProcessEnum:\n    permissible_values:\n      PROGRAMMED_CELL_DEATH:\n        title: Programmed Cell Death    # Human-friendly name\n        meaning: GO:0006915\n        aliases:\n          - apoptotic process           # Matches ontology label\n          - apoptosis\n</code></pre> <p>This will validate successfully because \"apoptotic process\" is in the aliases.</p>"},{"location":"schema-validation/#python-api","title":"Python API","text":"<pre><code>from linkml.validator import Validator\nfrom linkml_term_validator.plugins import PermissibleValueMeaningPlugin\n\n# Create plugin\nplugin = PermissibleValueMeaningPlugin(\n    oak_adapter_string=\"sqlite:obo:\",\n    strict_mode=False,\n    cache_labels=True,\n    cache_dir=\"cache\",\n)\n\n# Create validator\nvalidator = Validator(\n    schema=\"schema.yaml\",\n    validation_plugins=[plugin]\n)\n\n# Validate the schema file itself\nreport = validator.validate_file(\"schema.yaml\")\n\n# Check results\nif len(report.results) == 0:\n    print(\"All permissible values validated successfully\")\nelse:\n    for result in report.results:\n        print(f\"{result.severity.name}: {result.message}\")\n</code></pre>"},{"location":"schema-validation/#plugin-parameters","title":"Plugin Parameters","text":"Parameter Type Default Description <code>oak_adapter_string</code> <code>str</code> <code>\"sqlite:obo:\"</code> Default OAK adapter <code>oak_config_path</code> <code>str \\| None</code> <code>None</code> Path to OAK config file <code>strict_mode</code> <code>bool</code> <code>False</code> Treat warnings as errors <code>cache_labels</code> <code>bool</code> <code>True</code> Enable file-based caching <code>cache_dir</code> <code>str</code> <code>\"cache\"</code> Cache directory"},{"location":"schema-validation/#common-issues","title":"Common Issues","text":""},{"location":"schema-validation/#term-not-found-error","title":"\"Term not found\" Error","text":"<pre><code>ERROR: Term GO:9999999 not found in ontology\n</code></pre> <p>Causes: - Typo in the CURIE - Using an obsolete term ID - Ontology not available/configured</p> <p>Solutions: 1. Verify the CURIE exists in the ontology (use OLS) 2. Check for typos 3. Configure the correct OAK adapter</p>"},{"location":"schema-validation/#label-mismatch-warning","title":"\"Label mismatch\" Warning","text":"<pre><code>WARN: Label mismatch for GO:0007049\n  Expected: \"Cell Cycle\"\n  Found: \"cell cycle\"\n</code></pre> <p>This is usually fine - the validation is case-insensitive after normalization. If you see this warning, double-check your <code>title</code> or add the exact label as an alias.</p>"},{"location":"schema-validation/#unknown-prefix-info","title":"\"Unknown prefix\" Info","text":"<pre><code>INFO: Unknown prefix CUSTOM - skipping validation\n</code></pre> <p>Causes: - Using a custom/internal prefix not in standard ontologies - Prefix not configured in <code>oak_config.yaml</code></p> <p>Solutions: 1. Add the prefix to your <code>oak_config.yaml</code> if it maps to an ontology 2. Ignore if it's intentionally internal</p>"},{"location":"schema-validation/#best-practices","title":"Best Practices","text":"<ol> <li>Use <code>title</code> for human-readable names: The <code>title</code> field is your primary expected label</li> <li>Use <code>aliases</code> for synonyms: Add the ontology's canonical label as an alias if your preferred name differs</li> <li>Configure known prefixes: Create an <code>oak_config.yaml</code> for prefixes you use frequently</li> <li>Run in CI/CD: Add schema validation to your CI pipeline to catch issues early</li> <li>Use strict mode for releases: Use <code>--strict</code> when preparing a schema for release</li> </ol>"},{"location":"schema-validation/#see-also","title":"See Also","text":"<ul> <li>Enumerations - Understanding static vs dynamic enums</li> <li>Configuration - OAK adapter configuration</li> <li>Plugin Reference - Complete API reference</li> <li>CLI Reference - All CLI options</li> </ul>"},{"location":"validation-types/","title":"Validation Types","text":"<p>linkml-term-validator provides three distinct types of validation, each implemented as a composable LinkML ValidationPlugin.</p>"},{"location":"validation-types/#schema-validation-permissible-values","title":"Schema Validation (Permissible Values)","text":"<p>Plugin: <code>PermissibleValueMeaningPlugin</code></p> <p>Validates that <code>meaning</code> fields in enum permissible values reference valid ontology terms with correct labels.</p>"},{"location":"validation-types/#what-it-checks","title":"What it checks","text":"<ul> <li>The ontology term exists in the source ontology</li> <li>The term's canonical label matches the expected label from the schema</li> <li>Expected labels can come from: permissible value name, <code>title</code>, <code>description</code>, <code>aliases</code>, or annotation values</li> </ul>"},{"location":"validation-types/#example","title":"Example","text":"<p>Schema:</p> <pre><code>enums:\n  BiologicalProcessEnum:\n    permissible_values:\n      BIOLOGICAL_PROCESS:\n        title: biological process\n        meaning: GO:0008150  # \u2190 Validated\n</code></pre> <p>What gets validated:</p> <ol> <li>Check that <code>GO:0008150</code> exists in the Gene Ontology</li> <li>Retrieve the canonical label from GO (should be \"biological_process\")</li> <li>Compare against expected labels: \"BIOLOGICAL_PROCESS\", \"biological process\"</li> <li>Report if there's a mismatch or if the term doesn't exist</li> </ol>"},{"location":"validation-types/#when-to-use","title":"When to use","text":"<ul> <li>Validating LinkML schemas before publishing</li> <li>CI/CD checks on schema files</li> <li>Catching typos in term references</li> </ul>"},{"location":"validation-types/#commands","title":"Commands","text":"<pre><code># Basic validation\nlinkml-term-validator validate-schema schema.yaml\n\n# With strict mode\nlinkml-term-validator validate-schema --strict schema.yaml\n</code></pre>"},{"location":"validation-types/#dynamic-enum-validation","title":"Dynamic Enum Validation","text":"<p>Plugin: <code>DynamicEnumPlugin</code></p> <p>Validates data values against dynamic enum constraints defined via <code>reachable_from</code>, <code>matches</code>, or <code>concepts</code>.</p> <p>Dynamic enums define valid values using ontology queries rather than explicit lists, enabling flexible, extensible validation.</p>"},{"location":"validation-types/#what-it-checks_1","title":"What it checks","text":"<ul> <li>Data values match the ontology query constraints</li> <li>For <code>reachable_from</code>: value is a descendant of specified source nodes</li> <li>For <code>matches</code>: value matches the specified pattern</li> <li>For <code>concepts</code>: value is one of the specified concepts</li> </ul>"},{"location":"validation-types/#example_1","title":"Example","text":"<p>Schema:</p> <pre><code>enums:\n  NeuronTypeEnum:\n    description: Any neuron type\n    reachable_from:\n      source_ontology: sqlite:obo:cl\n      source_nodes:\n        - CL:0000540  # neuron\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre> <p>Data:</p> <pre><code>neurons:\n  - id: \"1\"\n    cell_type: CL:0000100  # Valid - is a descendant of CL:0000540\n  - id: \"2\"\n    cell_type: GO:0008150  # INVALID - not a neuron type\n</code></pre>"},{"location":"validation-types/#important-semantics","title":"Important semantics","text":"<ul> <li>Source nodes themselves are EXCLUDED by default</li> <li>Only descendants (via specified relationship types) are included</li> <li>Use actual descendant terms in your data, not the source node</li> </ul>"},{"location":"validation-types/#when-to-use_1","title":"When to use","text":"<ul> <li>Validating curated data files</li> <li>Ensuring data conforms to ontology-based constraints</li> <li>Flexible validation without hardcoding all valid values</li> </ul>"},{"location":"validation-types/#commands_1","title":"Commands","text":"<pre><code># Validate data with dynamic enums\nlinkml-term-validator validate-data data.yaml --schema schema.yaml\n\n# With specific target class\nlinkml-term-validator validate-data data.yaml -s schema.yaml -t Person\n</code></pre>"},{"location":"validation-types/#binding-validation","title":"Binding Validation","text":"<p>Plugin: <code>BindingValidationPlugin</code></p> <p>Validates that nested object fields satisfy binding range constraints.</p> <p>Bindings allow you to constrain the values of nested object fields based on dynamic enums, providing type safety for ontology references.</p>"},{"location":"validation-types/#what-it-checks_2","title":"What it checks","text":"<ul> <li>The value in the nested object's field matches the binding's range constraint</li> <li>Optionally: the label in the nested object matches the ontology's canonical label</li> <li>Recursively validates all nested structures - bindings on deeply nested classes are validated with full JSON path tracking</li> </ul>"},{"location":"validation-types/#explicit-label-field-declaration","title":"Explicit Label Field Declaration","text":"<p>Use <code>implements</code> or <code>slot_uri</code> to explicitly declare which fields should be validated as labels:</p> <pre><code>classes:\n  GOTerm:\n    attributes:\n      id:\n        identifier: true\n      name:\n        implements:\n          - rdfs:label  # Option 1: implements list\n      # OR\n      label:\n        slot_uri: rdfs:label  # Option 2: slot_uri\n</code></pre> <p>Supported label properties:</p> <ul> <li><code>rdfs:label</code> - Standard RDF label</li> <li><code>skos:prefLabel</code> - SKOS preferred label</li> <li><code>schema:name</code> - Schema.org name</li> <li><code>oboInOwl:hasExactSynonym</code> - OBO exact synonym</li> </ul> <p>If no <code>implements</code> or <code>slot_uri</code> is specified, the validator falls back to looking for a field named <code>label</code> (convention-based).</p>"},{"location":"validation-types/#example_2","title":"Example","text":"<p>Schema:</p> <pre><code>classes:\n  GeneAnnotation:\n    slots:\n      - gene\n      - go_term\n    slot_usage:\n      go_term:\n        range: GOTerm\n        bindings:\n          - binds_value_of: id\n            range: BiologicalProcessEnum  # \u2190 Binding constraint\n\n  GOTerm:\n    slots:\n      - id\n      - label\n\nenums:\n  BiologicalProcessEnum:\n    reachable_from:\n      source_ontology: sqlite:obo:go\n      source_nodes:\n        - GO:0008150  # biological_process\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre> <p>Data:</p> <pre><code>annotations:\n  - gene: BRCA1\n    go_term:\n      id: GO:0007049  # Valid - is a biological process\n      label: cell cycle\n</code></pre> <p>What gets validated:</p> <ol> <li>Check that <code>go_term.id</code> value (<code>GO:0007049</code>) satisfies the <code>BiologicalProcessEnum</code> constraint</li> <li>If <code>--labels</code> flag is used, also check that <code>go_term.label</code> matches the canonical label from GO</li> </ol>"},{"location":"validation-types/#when-to-use_2","title":"When to use","text":"<ul> <li>Validating complex nested data structures</li> <li>Enforcing ontology constraints on object references</li> <li>Label validation for AI-generated data</li> </ul>"},{"location":"validation-types/#commands_2","title":"Commands","text":"<pre><code># Validate bindings only\nlinkml-term-validator validate-data data.yaml --schema schema.yaml\n\n# Also validate labels match ontology\nlinkml-term-validator validate-data data.yaml --schema schema.yaml --labels\n</code></pre>"},{"location":"validation-types/#label-matching","title":"Label Matching","text":"<p>When validating <code>meaning</code> fields, the validator compares the ontology's canonical label against multiple expected sources:</p> <ol> <li>Permissible value name (e.g., <code>BIOLOGICAL_PROCESS</code>)</li> <li>Title field (e.g., <code>title: biological process</code>)</li> <li>Description field</li> <li>Aliases (e.g., <code>aliases: [biological_process, bio process]</code>)</li> <li>Annotation values for tags like <code>label</code>, <code>display_name</code>, <code>synonym</code></li> </ol> <p>Labels are normalized before comparison:</p> <ul> <li>Lowercased</li> <li>Spaces/underscores treated as equivalent</li> <li>Multiple whitespace collapsed to single space</li> </ul> <p>This flexible matching reduces false positives from minor formatting differences.</p>"},{"location":"validation-types/#severity-levels","title":"Severity Levels","text":"<p>Validation results are reported with different severity levels:</p> <ul> <li>ERROR - Serious issue that should block data/schema acceptance</li> <li>Configured prefix with label mismatch</li> <li>Missing term from configured ontology</li> <li>Dynamic enum constraint violation</li> <li> <p>Binding constraint violation</p> </li> <li> <p>WARN - Potential issue that may need attention</p> </li> <li>Label mismatch in non-strict mode</li> <li> <p>Unconfigured prefix with label mismatch (when verbose)</p> </li> <li> <p>INFO - Informational message</p> </li> <li>Unconfigured prefix encountered</li> <li>Unknown prefix summary</li> </ul>"},{"location":"validation-types/#strict-mode","title":"Strict Mode","text":"<p>Use <code>--strict</code> to treat all warnings as errors:</p> <pre><code>linkml-term-validator validate-schema --strict schema.yaml\n</code></pre>"},{"location":"validation-types/#see-also","title":"See Also","text":"<ul> <li>Configuration - How to configure ontology adapters</li> <li>Caching - Understanding the caching system</li> <li>Anti-Hallucination - Using validation for AI guardrails</li> </ul>"}]}