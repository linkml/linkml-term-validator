{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"linkml-term-validator","text":"<p>Validating LinkML schemas and datasets that depend on external ontology terms</p> <p>A collection of LinkML ValidationPlugin implementations for validating ontology term references in schemas and data.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u2705 Three composable validation plugins for the LinkML validator framework</li> <li>\u2705 Schema validation - Validates <code>meaning</code> fields in enum permissible values</li> <li>\u2705 Dynamic enum validation - Validates data against <code>reachable_from</code>, <code>matches</code>, <code>concepts</code></li> <li>\u2705 Binding validation - Validates constraints on nested object fields</li> <li>\u2705 Multi-level caching - In-memory + file-based for fast repeated validation</li> <li>\u2705 Ontology Access Kit (OAK) integration - Supports multiple ontology sources</li> <li>\u2705 AI hallucination prevention - Dual validation (ID + label) for AI-generated terms</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install linkml-term-validator\n</code></pre>"},{"location":"#validate-a-schema","title":"Validate a Schema","text":"<p>Check that <code>meaning</code> fields reference valid ontology terms:</p> <pre><code>linkml-term-validator validate-schema schema.yaml\n</code></pre>"},{"location":"#validate-data","title":"Validate Data","text":"<p>Validate data instances against dynamic enums and binding constraints:</p> <pre><code>linkml-term-validator validate-data data.yaml --schema schema.yaml\n</code></pre>"},{"location":"#documentation-quick-links","title":"Documentation Quick Links","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Getting Started Tutorial - Interactive notebook for CLI basics</li> <li>CLI Reference - Complete command-line documentation</li> <li>Configuration - Configure ontology adapters and caching</li> </ul>"},{"location":"#understanding-validation","title":"Understanding Validation","text":"<ul> <li>Validation Types - Schema, dynamic enum, and binding validation explained</li> <li>Anti-Hallucination Guardrails - Preventing AI from hallucinating ontology IDs</li> <li>Ontology Access - How OAK adapters work</li> </ul>"},{"location":"#integration","title":"Integration","text":"<ul> <li>linkml-validate Integration - Use plugins with standard linkml-validate</li> <li>Python API - Programmatic usage</li> <li>Plugin Reference - Complete API documentation</li> </ul>"},{"location":"#advanced-topics","title":"Advanced Topics","text":"<ul> <li>TSV/CSV Data Validation - Validating tabular data</li> <li>Advanced Usage - Custom configs, local files, troubleshooting</li> <li>Caching - Understanding the caching system</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Schema Quality Assurance - Catch typos and mismatches in ontology term references before publishing</li> <li>Data Validation - Ensure curated datasets only use valid, constrained ontology terms</li> <li>AI-Generated Content - Prevent language models from hallucinating fake ontology identifiers</li> <li>CI/CD Integration - Automated validation in continuous integration pipelines</li> <li>Flexible Constraints - Define valid terms via ontology queries rather than hardcoded lists</li> </ul>"},{"location":"anti-hallucination/","title":"Anti-Hallucination Guardrails","text":"<p>A key use case for linkml-term-validator is preventing AI systems from hallucinating ontology identifiers.</p>"},{"location":"anti-hallucination/#the-problem","title":"The Problem","text":"<p>Language models frequently hallucinate identifiers like gene IDs, ontology terms, and other structured references. These fake identifiers often appear structurally correct (e.g., <code>GO:9999999</code>, <code>CHEBI:88888</code>) but don't actually exist in the source ontologies.</p> <p>This creates serious data quality issues: - Invalid references that break data integration - Nonsense annotations that corrupt curated datasets - False confidence in AI-generated content</p>"},{"location":"anti-hallucination/#the-solution-dual-validation","title":"The Solution: Dual Validation","text":"<p>A robust guardrail requires dual validation\u2014forcing the AI to provide both the identifier AND its canonical label, then validating that they match:</p> <p>Instead of accepting:</p> <pre><code>term: GO:0005515  # Single piece of information - easy to hallucinate\n</code></pre> <p>Require and validate:</p> <pre><code>term:\n  id: GO:0005515\n  label: protein binding  # Must match canonical label in ontology\n</code></pre> <p>This dramatically reduces hallucinations because the AI must get two interdependent facts correct simultaneously, which is significantly harder to fake convincingly than inventing a single plausible-looking identifier.</p>"},{"location":"anti-hallucination/#implementation-pattern","title":"Implementation Pattern","text":""},{"location":"anti-hallucination/#1-define-schemas-with-binding-constraints","title":"1. Define Schemas with Binding Constraints","text":"<pre><code>classes:\n  GeneAnnotation:\n    slots:\n      - gene\n      - go_term\n    slot_usage:\n      go_term:\n        range: GOTerm\n        bindings:\n          - binds_value_of: id\n            range: BiologicalProcessEnum\n\n  GOTerm:\n    slots:\n      - id        # AI must provide both\n      - label     # fields correctly\n\nenums:\n  BiologicalProcessEnum:\n    reachable_from:\n      source_ontology: sqlite:obo:go\n      source_nodes:\n        - GO:0008150  # biological_process\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre>"},{"location":"anti-hallucination/#2-validate-ai-generated-outputs-before-committing","title":"2. Validate AI-Generated Outputs Before Committing","text":"<pre><code>from linkml.validator import Validator\nfrom linkml_term_validator.plugins import BindingValidationPlugin\n\n# Create validator with label checking enabled\nplugin = BindingValidationPlugin(\n    oak_adapter_string=\"sqlite:obo:\",\n    validate_labels=True\n)\nvalidator = Validator(schema=\"schema.yaml\", validation_plugins=[plugin])\n\n# Validate AI-generated data\nreport = validator.validate_source(loader, target_class=\"GeneAnnotation\")\n\nif len(report.results) &gt; 0:\n    # Reject hallucinated terms, prompt AI to regenerate\n    for result in report.results:\n        print(f\"ERROR: {result.message}\")\n    raise ValueError(\"Invalid ontology terms detected\")\n</code></pre>"},{"location":"anti-hallucination/#3-use-validation-during-generation","title":"3. Use Validation During Generation","text":"<p>The most effective approach embeds validation during AI generation rather than treating it as a filtering step afterward. This transforms hallucination resistance from a detection problem into a generation constraint.</p> <p>Pattern: 1. AI generates structured output with id+label pairs 2. Validate immediately with <code>BindingValidationPlugin(validate_labels=True)</code> 3. If validation fails, provide error messages back to AI with retry opportunity 4. Only accept outputs that pass validation</p>"},{"location":"anti-hallucination/#what-gets-validated","title":"What Gets Validated","text":"<p>The <code>BindingValidationPlugin</code> with <code>validate_labels=True</code> checks:</p> <ol> <li>ID exists in ontology: The identifier (e.g., <code>GO:0005515</code>) is a real term</li> <li>ID matches constraint: The term satisfies the binding's range constraint (e.g., is a biological process)</li> <li>Label matches ontology: The provided label matches the canonical label from the ontology</li> </ol> <p>All three checks must pass.</p>"},{"location":"anti-hallucination/#real-world-benefits","title":"Real-World Benefits","text":"<ul> <li>Prevents fake identifiers from entering curated datasets</li> <li>Catches label mismatches where AI uses real IDs but wrong labels</li> <li>Validates dynamic constraints (e.g., only disease terms, only neuron types)</li> <li>Enables reliable automation of curation tasks traditionally requiring human experts</li> </ul>"},{"location":"anti-hallucination/#example-invalid-ai-output","title":"Example: Invalid AI Output","text":"<pre><code>annotations:\n  - gene: BRCA1\n    go_term:\n      id: GO:0005515\n      label: DNA binding  # \u274c WRONG - actual label is \"protein binding\"\n</code></pre> <p>Validation result:</p> <pre><code>ERROR: Label mismatch for GO:0005515\n  Expected: protein binding\n  Found: DNA binding\n</code></pre>"},{"location":"anti-hallucination/#example-hallucinated-id","title":"Example: Hallucinated ID","text":"<pre><code>annotations:\n  - gene: BRCA1\n    go_term:\n      id: GO:9999999  # \u274c Doesn't exist\n      label: cell stuff\n</code></pre> <p>Validation result:</p> <pre><code>ERROR: GO:9999999 not found in Gene Ontology\n</code></pre>"},{"location":"anti-hallucination/#cli-usage","title":"CLI Usage","text":"<pre><code># Validate with label checking enabled\nlinkml-term-validator validate-data data.yaml \\\n  --schema schema.yaml \\\n  --labels  # Enable label validation\n</code></pre>"},{"location":"anti-hallucination/#best-practices","title":"Best Practices","text":"<ol> <li>Always use dual validation (id + label) for AI-generated ontology references</li> <li>Provide clear error messages back to the AI when validation fails</li> <li>Use dynamic enums to constrain valid terms (e.g., only disease terms)</li> <li>Cache ontology labels for fast validation during generation</li> <li>Validate early and often - don't wait until after bulk generation</li> </ol>"},{"location":"anti-hallucination/#learn-more","title":"Learn More","text":"<p>For detailed patterns and best practices on making ontology IDs hallucination-resistant in AI workflows, see:</p> <ul> <li>Make IDs Hallucination Resistant - Comprehensive guide from the AI for Curation project</li> <li>Python API Tutorial - Interactive notebook demonstrating validation workflows</li> <li>Advanced Usage - CLI patterns for binding validation</li> </ul>"},{"location":"anti-hallucination/#see-also","title":"See Also","text":"<ul> <li>Binding Validation - Technical details</li> <li>Python API - Programmatic usage</li> </ul>"},{"location":"caching/","title":"Caching","text":"<p>The validator uses multi-level caching to speed up repeated validations and avoid redundant ontology queries.</p>"},{"location":"caching/#in-memory-cache","title":"In-Memory Cache","text":"<p>During a single validation run, ontology labels are cached in memory. If multiple permissible values reference the same term, it's only looked up once.</p> <p>This cache exists only for the duration of the validation process and is discarded afterward.</p>"},{"location":"caching/#file-based-cache","title":"File-Based Cache","text":"<p>Labels are persisted to CSV files in the cache directory (default: <code>./cache</code>):</p> <pre><code>cache/\n\u251c\u2500\u2500 go/\n\u2502   \u2514\u2500\u2500 terms.csv      # GO term labels\n\u251c\u2500\u2500 chebi/\n\u2502   \u2514\u2500\u2500 terms.csv      # CHEBI term labels\n\u2514\u2500\u2500 uberon/\n    \u2514\u2500\u2500 terms.csv      # UBERON term labels\n</code></pre>"},{"location":"caching/#cache-file-format","title":"Cache File Format","text":"<p>Cache files use a simple CSV format:</p> <pre><code>curie,label,retrieved_at\nGO:0008150,biological_process,2025-11-15T10:30:00\nGO:0007049,cell cycle,2025-11-15T10:30:01\n</code></pre>"},{"location":"caching/#cache-behavior","title":"Cache Behavior","text":"<ul> <li>First run: Queries ontology databases, saves results to cache</li> <li>Subsequent runs: Loads from cache files (very fast, no network/database access)</li> <li>Cache location: Configurable via <code>--cache-dir</code> flag</li> <li>Disable caching: Use <code>--no-cache</code> flag</li> </ul>"},{"location":"caching/#configuration","title":"Configuration","text":""},{"location":"caching/#cli","title":"CLI","text":"<pre><code># Use custom cache directory\nlinkml-term-validator validate-schema --cache-dir /path/to/cache schema.yaml\n\n# Disable caching\nlinkml-term-validator validate-schema --no-cache schema.yaml\n</code></pre>"},{"location":"caching/#python-api","title":"Python API","text":"<pre><code>from linkml_term_validator.plugins import DynamicEnumPlugin\n\nplugin = DynamicEnumPlugin(\n    cache_dir=\"/path/to/cache\",\n    cache_labels=True  # Enable/disable file-based caching\n)\n</code></pre>"},{"location":"caching/#linkml-validate-configuration","title":"linkml-validate Configuration","text":"<pre><code>plugins:\n  \"linkml_term_validator.plugins.DynamicEnumPlugin\":\n    oak_adapter_string: \"sqlite:obo:\"\n    cache_labels: true\n    cache_dir: cache\n</code></pre>"},{"location":"caching/#when-to-clear-cache","title":"When to Clear Cache","text":"<p>You might want to clear the cache if:</p> <ul> <li>Ontology databases have been updated and you need the latest labels</li> <li>You suspect stale or incorrect labels in cached data</li> <li>You're testing validation behavior and want to force fresh lookups</li> </ul> <pre><code># Clear cache for specific ontology\nrm -rf cache/go/\n\n# Clear entire cache\nrm -rf cache/\n</code></pre>"},{"location":"caching/#performance-benefits","title":"Performance Benefits","text":"<p>Caching provides significant performance improvements:</p> <ul> <li>First validation: May take several seconds per ontology (database queries)</li> <li>Cached validations: Typically &lt; 100ms (CSV file reads)</li> <li>No network dependency: Cached validations work offline</li> </ul>"},{"location":"caching/#cache-safety","title":"Cache Safety","text":"<p>The cache is read-only during validation and only contains: - CURIEs (ontology identifiers) - Canonical labels - Timestamps</p> <p>Cached data cannot affect validation logic, only speed up lookups.</p>"},{"location":"caching/#see-also","title":"See Also","text":"<ul> <li>Configuration - Complete configuration options</li> <li>Ontology Access - How ontology adapters work</li> </ul>"},{"location":"cli-reference/","title":"CLI Reference","text":"<p>Complete command-line interface reference for linkml-term-validator.</p>"},{"location":"cli-reference/#overview","title":"Overview","text":"<p>linkml-term-validator provides a single command <code>linkml-term-validator</code> with two subcommands:</p> <ul> <li><code>validate-schema</code> - Validate schema permissible values</li> <li><code>validate-data</code> - Validate data against dynamic enums and bindings</li> </ul>"},{"location":"cli-reference/#installation","title":"Installation","text":"<pre><code>pip install linkml-term-validator\n</code></pre> <p>Or with <code>uv</code>:</p> <pre><code>uv add linkml-term-validator\n</code></pre>"},{"location":"cli-reference/#global-options","title":"Global Options","text":"<p>These options apply to all subcommands:</p> <pre><code>linkml-term-validator [OPTIONS] COMMAND [ARGS]\n</code></pre> Option Description <code>--help</code> Show help message and exit"},{"location":"cli-reference/#validate-schema","title":"validate-schema","text":"<p>Validates that <code>meaning</code> fields in enum permissible values reference valid ontology terms with correct labels.</p>"},{"location":"cli-reference/#syntax","title":"Syntax","text":"<pre><code>linkml-term-validator validate-schema [OPTIONS] SCHEMA_PATH\n</code></pre>"},{"location":"cli-reference/#arguments","title":"Arguments","text":"Argument Type Required Description <code>SCHEMA_PATH</code> Path Yes Path to LinkML schema file (<code>.yaml</code>)"},{"location":"cli-reference/#options","title":"Options","text":"Option Type Default Description <code>--config PATH</code> Path None Path to OAK config file (<code>oak_config.yaml</code>) for per-prefix adapter configuration <code>--adapter TEXT</code> String <code>\"sqlite:obo:\"</code> Default OAK adapter string (e.g., <code>sqlite:obo:</code>, <code>ols:</code>, <code>bioportal:</code>) <code>--cache-dir PATH</code> Path <code>cache</code> Directory for caching ontology labels <code>--no-cache</code> Flag False Disable file-based caching <code>--strict</code> Flag False Treat warnings as errors <code>--verbose</code> Flag False Show detailed validation information <code>--help</code> Flag - Show help message and exit"},{"location":"cli-reference/#examples","title":"Examples","text":"<p>Basic validation:</p> <pre><code>linkml-term-validator validate-schema schema.yaml\n</code></pre> <p>With custom config:</p> <pre><code>linkml-term-validator validate-schema --config oak_config.yaml schema.yaml\n</code></pre> <p>Strict mode (warnings become errors):</p> <pre><code>linkml-term-validator validate-schema --strict schema.yaml\n</code></pre> <p>Using OLS instead of SQLite:</p> <pre><code>linkml-term-validator validate-schema --adapter ols: schema.yaml\n</code></pre> <p>Disable caching:</p> <pre><code>linkml-term-validator validate-schema --no-cache schema.yaml\n</code></pre> <p>Verbose output:</p> <pre><code>linkml-term-validator validate-schema --verbose schema.yaml\n</code></pre> <p>Custom cache directory:</p> <pre><code>linkml-term-validator validate-schema --cache-dir /tmp/ontology-cache schema.yaml\n</code></pre>"},{"location":"cli-reference/#output","title":"Output","text":"<p>Success (no issues):</p> <pre><code>\u2705 Validation passed!\n\nValidation Summary:\n  Enums checked: 2\n  Permissible values checked: 4\n  Meanings validated: 4\n  Issues found: 0\n</code></pre> <p>Failure (with issues):</p> <pre><code>\u274c ERROR: Label mismatch for GO:0008150\n    Enum: BiologicalProcessEnum\n    Permissible value: BIOLOGICAL_PROCESS\n    Expected label: biological process\n    Found label: biological_process\n\nValidation Summary:\n  Enums checked: 2\n  Permissible values checked: 4\n  Meanings validated: 4\n  Issues found: 1\n    Errors: 1\n    Warnings: 0\n</code></pre> <p>With unknown prefixes:</p> <pre><code>\u2705 Validation passed!\n\nValidation Summary:\n  Enums checked: 2\n  Permissible values checked: 5\n  Meanings validated: 4\n  Issues found: 0\n\n\u26a0\ufe0f  Unknown prefixes encountered (validation skipped):\n  - MY_CUSTOM\n  - INTERNAL\n\nConsider adding these to oak_config.yaml to enable validation.\n</code></pre>"},{"location":"cli-reference/#exit-codes","title":"Exit Codes","text":"Code Meaning 0 Success - no validation errors 1 Failure - validation errors found"},{"location":"cli-reference/#validate-data","title":"validate-data","text":"<p>Validates data instances against dynamic enums and binding constraints.</p>"},{"location":"cli-reference/#syntax_1","title":"Syntax","text":"<pre><code>linkml-term-validator validate-data [OPTIONS] DATA_PATH\n</code></pre>"},{"location":"cli-reference/#arguments_1","title":"Arguments","text":"Argument Type Required Description <code>DATA_PATH</code> Path Yes Path to data file (<code>.yaml</code>, <code>.json</code>)"},{"location":"cli-reference/#options_1","title":"Options","text":"Option Type Default Description <code>--schema PATH</code> Path Required Path to LinkML schema file <code>--target-class TEXT</code> String None Target class name to validate against <code>--config PATH</code> Path None Path to OAK config file <code>--adapter TEXT</code> String <code>\"sqlite:obo:\"</code> Default OAK adapter string <code>--cache-dir PATH</code> Path <code>cache</code> Directory for caching ontology labels <code>--no-cache</code> Flag False Disable file-based caching <code>--labels</code> Flag False Validate that labels match ontology canonical labels <code>--no-dynamic-enums</code> Flag False Skip dynamic enum validation <code>--no-bindings</code> Flag False Skip binding constraint validation <code>--verbose</code> Flag False Show detailed validation information <code>--help</code> Flag - Show help message and exit"},{"location":"cli-reference/#examples_1","title":"Examples","text":"<p>Basic validation:</p> <pre><code>linkml-term-validator validate-data data.yaml --schema schema.yaml\n</code></pre> <p>With target class:</p> <pre><code>linkml-term-validator validate-data data.yaml --schema schema.yaml --target-class Person\n</code></pre> <p>With label validation:</p> <pre><code>linkml-term-validator validate-data data.yaml --schema schema.yaml --labels\n</code></pre> <p>With custom config:</p> <pre><code>linkml-term-validator validate-data data.yaml \\\n  --schema schema.yaml \\\n  --config oak_config.yaml\n</code></pre> <p>Only validate bindings (skip dynamic enums):</p> <pre><code>linkml-term-validator validate-data data.yaml \\\n  --schema schema.yaml \\\n  --no-dynamic-enums\n</code></pre> <p>Only validate dynamic enums (skip bindings):</p> <pre><code>linkml-term-validator validate-data data.yaml \\\n  --schema schema.yaml \\\n  --no-bindings\n</code></pre> <p>Full validation with all options:</p> <pre><code>linkml-term-validator validate-data data.yaml \\\n  --schema schema.yaml \\\n  --target-class GeneAnnotation \\\n  --config oak_config.yaml \\\n  --cache-dir cache \\\n  --labels \\\n  --verbose\n</code></pre>"},{"location":"cli-reference/#output_1","title":"Output","text":"<p>Success (no issues):</p> <pre><code>\u2705 Validation passed!\n\nValidation Summary:\n  Dynamic enums validated: 5\n  Bindings validated: 3\n  Issues found: 0\n</code></pre> <p>Failure (dynamic enum violation):</p> <pre><code>\u274c ERROR: Value 'GO:0005575' does not satisfy dynamic enum constraint\n    Class: GeneAnnotation\n    Slot: go_term.id\n    Enum: BiologicalProcessEnum\n    Expected: Descendant of GO:0008150 (biological_process)\n    Found: GO:0005575 (cellular_component)\n\nValidation Summary:\n  Dynamic enums validated: 5\n  Bindings validated: 3\n  Issues found: 1\n    Errors: 1\n</code></pre> <p>Failure (label mismatch with --labels):</p> <pre><code>\u274c ERROR: Label mismatch for GO:0007049\n    Class: GeneAnnotation\n    Slot: go_term.label\n    Expected label: cell cycle\n    Found label: cell-division cycle\n\nValidation Summary:\n  Dynamic enums validated: 5\n  Bindings validated: 3\n  Label validations: 3\n  Issues found: 1\n    Errors: 1\n</code></pre>"},{"location":"cli-reference/#exit-codes_1","title":"Exit Codes","text":"Code Meaning 0 Success - no validation errors 1 Failure - validation errors found"},{"location":"cli-reference/#common-workflows","title":"Common Workflows","text":""},{"location":"cli-reference/#cicd-validation","title":"CI/CD Validation","text":"<p>Schema validation in CI:</p> <pre><code>#!/bin/bash\nset -e  # Exit on error\n\necho \"Validating LinkML schemas...\"\nlinkml-term-validator validate-schema \\\n  --strict \\\n  --config oak_config.yaml \\\n  --cache-dir cache \\\n  src/schema/main.yaml\n\necho \"\u2705 Schema validation passed\"\n</code></pre> <p>Data validation in CI:</p> <pre><code>#!/bin/bash\nset -e\n\necho \"Validating curated data...\"\nlinkml-term-validator validate-data \\\n  data/curated/*.yaml \\\n  --schema src/schema/main.yaml \\\n  --config oak_config.yaml \\\n  --labels \\\n  --cache-dir cache\n\necho \"\u2705 Data validation passed\"\n</code></pre>"},{"location":"cli-reference/#local-development","title":"Local Development","text":"<p>Quick schema check:</p> <pre><code>linkml-term-validator validate-schema schema.yaml\n</code></pre> <p>Validate with fresh cache:</p> <pre><code>rm -rf cache/\nlinkml-term-validator validate-schema schema.yaml\n</code></pre> <p>Test with OLS (no local downloads):</p> <pre><code>linkml-term-validator validate-schema --adapter ols: --no-cache schema.yaml\n</code></pre>"},{"location":"cli-reference/#debugging","title":"Debugging","text":"<p>Verbose output:</p> <pre><code>linkml-term-validator validate-schema --verbose schema.yaml\n</code></pre> <p>Check specific data file:</p> <pre><code>linkml-term-validator validate-data \\\n  data/problematic.yaml \\\n  --schema schema.yaml \\\n  --verbose\n</code></pre>"},{"location":"cli-reference/#configuration-files","title":"Configuration Files","text":""},{"location":"cli-reference/#oak_configyaml","title":"oak_config.yaml","text":"<p>Controls which ontology adapters to use for different prefixes:</p> <pre><code>ontology_adapters:\n  GO: sqlite:obo:go\n  CHEBI: sqlite:obo:chebi\n  UBERON: sqlite:obo:uberon\n\n  # Skip validation\n  linkml: \"\"\n  schema: \"\"\n</code></pre> <p>Use with:</p> <pre><code>linkml-term-validator validate-schema --config oak_config.yaml schema.yaml\n</code></pre> <p>See Configuration for details.</p>"},{"location":"cli-reference/#shell-completion","title":"Shell Completion","text":""},{"location":"cli-reference/#bash","title":"Bash","text":"<pre><code># Add to ~/.bashrc\neval \"$(_LINKML_TERM_VALIDATOR_COMPLETE=bash_source linkml-term-validator)\"\n</code></pre>"},{"location":"cli-reference/#zsh","title":"Zsh","text":"<pre><code># Add to ~/.zshrc\neval \"$(_LINKML_TERM_VALIDATOR_COMPLETE=zsh_source linkml-term-validator)\"\n</code></pre>"},{"location":"cli-reference/#fish","title":"Fish","text":"<pre><code># Add to ~/.config/fish/config.fish\n_LINKML_TERM_VALIDATOR_COMPLETE=fish_source linkml-term-validator | source\n</code></pre>"},{"location":"cli-reference/#environment-variables","title":"Environment Variables","text":"Variable Description Default <code>BIOPORTAL_API_KEY</code> API key for BioPortal adapter None <code>OAK_CACHE_DIR</code> Default cache directory for OAK <code>~/.data/oaklib</code>"},{"location":"cli-reference/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli-reference/#command-not-found","title":"Command not found","text":"<p>Problem:</p> <pre><code>linkml-term-validator: command not found\n</code></pre> <p>Solution: Ensure the package is installed and your PATH is configured:</p> <pre><code>pip install linkml-term-validator\nwhich linkml-term-validator\n</code></pre>"},{"location":"cli-reference/#unknown-prefixes","title":"Unknown prefixes","text":"<p>Problem:</p> <pre><code>\u26a0\ufe0f  Unknown prefixes encountered (validation skipped):\n  - MY_ONTOLOGY\n</code></pre> <p>Solution: Add the prefix to your <code>oak_config.yaml</code>:</p> <pre><code>ontology_adapters:\n  MY_ONTOLOGY: sqlite:obo:my_ontology\n</code></pre> <p>Or use a local OBO file:</p> <pre><code>ontology_adapters:\n  MY_ONTOLOGY: simpleobo:path/to/ontology.obo\n</code></pre>"},{"location":"cli-reference/#slow-validation","title":"Slow validation","text":"<p>Problem: Validation takes a long time on first run.</p> <p>Solution: This is expected when using <code>sqlite:obo:</code> adapter for the first time. OAK is downloading and building the ontology database. Subsequent runs will be fast due to caching.</p> <p>To speed up development: - Use <code>simpleobo:</code> adapter with local OBO files for testing - Cache the <code>cache/</code> directory in CI/CD - Use <code>ols:</code> adapter to avoid local downloads (slower per query but no initial download)</p>"},{"location":"cli-reference/#stale-cache","title":"Stale cache","text":"<p>Problem: Validation shows old labels even though ontology has been updated.</p> <p>Solution: Clear the cache:</p> <pre><code>rm -rf cache/\nlinkml-term-validator validate-schema schema.yaml\n</code></pre> <p>Or disable caching:</p> <pre><code>linkml-term-validator validate-schema --no-cache schema.yaml\n</code></pre>"},{"location":"cli-reference/#see-also","title":"See Also","text":"<ul> <li>Configuration - Detailed configuration options</li> <li>Plugin Reference - Python API documentation</li> <li>Tutorials - Interactive tutorials</li> <li>Validation Types - Understanding validation types</li> <li>Anti-Hallucination Guardrails - Preventing AI hallucinations</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>This page details how to configure linkml-term-validator to control ontology access and validation behavior.</p>"},{"location":"configuration/#oak-configuration-file","title":"OAK Configuration File","text":"<p>The primary way to configure ontology access is through an <code>oak_config.yaml</code> file that maps ontology prefixes to OAK adapter strings.</p>"},{"location":"configuration/#basic-structure","title":"Basic Structure","text":"<pre><code>ontology_adapters:\n  # Prefix: adapter_string\n  GO: sqlite:obo:go\n  CHEBI: sqlite:obo:chebi\n  UBERON: sqlite:obo:uberon\n</code></pre>"},{"location":"configuration/#using-the-config-file","title":"Using the Config File","text":"<p>CLI:</p> <pre><code>linkml-term-validator validate-schema --config oak_config.yaml schema.yaml\nlinkml-term-validator validate-data --config oak_config.yaml data.yaml --schema schema.yaml\n</code></pre> <p>Python API:</p> <pre><code>from linkml_term_validator.plugins import PermissibleValueMeaningPlugin\n\nplugin = PermissibleValueMeaningPlugin(oak_config_path=\"oak_config.yaml\")\n</code></pre>"},{"location":"configuration/#important-behavior","title":"Important Behavior","text":"<p>When using <code>oak_config.yaml</code>:</p> <ul> <li>ONLY prefixes listed in the config are validated</li> <li>Unlisted prefixes are tracked as \"unknown\" and reported at the end</li> <li>Unknown prefixes are NOT validated (no errors/warnings for these terms)</li> </ul> <p>This allows you to control which ontologies require validation and skip validation for prefixes you don't care about.</p>"},{"location":"configuration/#oak-adapter-strings","title":"OAK Adapter Strings","text":"<p>OAK adapter strings specify how to access an ontology. Different adapters support different backends and use cases.</p>"},{"location":"configuration/#common-adapters","title":"Common Adapters","text":""},{"location":"configuration/#sqliteobo-default-recommended","title":"sqlite:obo: (Default, Recommended)","text":"<p>Uses pre-downloaded OBO ontologies in SQLite format. Fast, works offline, caches locally.</p> <p>Usage:</p> <pre><code>ontology_adapters:\n  GO: sqlite:obo:go\n  CHEBI: sqlite:obo:chebi\n  UBERON: sqlite:obo:uberon\n</code></pre> <p>First-time setup:</p> <p>The first time you validate with a new ontology, OAK will download and build the SQLite database. This can take a few minutes but only happens once.</p> <p>Pros: - Fast queries (SQLite is efficient) - Works offline after initial download - No rate limiting - Consistent results</p> <p>Cons: - Requires initial download - Takes disk space (~100MB-1GB per ontology) - Need to manually update for latest ontology versions</p>"},{"location":"configuration/#simpleobo","title":"simpleobo:","text":"<p>Uses local OBO files directly. Good for unit tests and custom ontologies.</p> <p>Usage:</p> <pre><code>ontology_adapters:\n  MY_CUSTOM: simpleobo:path/to/my_ontology.obo\n  TEST: simpleobo:tests/data/test_ontology.obo\n</code></pre> <p>Pros: - Fast, lightweight - Perfect for testing - No network access required - Full control over ontology version</p> <p>Cons: - Limited query capabilities compared to SQLite - Only works with OBO format - Need to manage OBO files yourself</p>"},{"location":"configuration/#ols","title":"ols:","text":"<p>Uses the Ontology Lookup Service (EBI). Online service, no local downloads.</p> <p>Usage:</p> <pre><code>ontology_adapters:\n  GO: ols:\n  CHEBI: ols:\n  UBERON: ols:\n</code></pre> <p>Pros: - No local downloads - Always uses latest ontology versions - Works out-of-the-box</p> <p>Cons: - Requires internet connection - Slower than local adapters - Subject to rate limiting - Service availability dependence</p>"},{"location":"configuration/#bioportal","title":"bioportal:","text":"<p>Uses NCBO BioPortal. Requires API key.</p> <p>Usage:</p> <pre><code>ontology_adapters:\n  GO: bioportal:\n  CHEBI: bioportal:\n</code></pre> <p>Setup:</p> <p>Set <code>BIOPORTAL_API_KEY</code> environment variable:</p> <pre><code>export BIOPORTAL_API_KEY=your-api-key-here\nlinkml-term-validator validate-schema --config oak_config.yaml schema.yaml\n</code></pre> <p>Pros: - Access to many ontologies - Well-maintained service - Good coverage</p> <p>Cons: - Requires API key registration - Subject to rate limiting - Requires internet connection</p>"},{"location":"configuration/#skipping-validation-for-specific-prefixes","title":"Skipping Validation for Specific Prefixes","text":"<p>To skip validation for certain prefixes, use an empty string:</p> <pre><code>ontology_adapters:\n  GO: sqlite:obo:go\n  CHEBI: sqlite:obo:chebi\n\n  # Skip validation for these prefixes\n  xsd: \"\"\n  rdf: \"\"\n  linkml: \"\"\n  schema: \"\"\n</code></pre> <p>Terms with these prefixes will not be validated and won't generate warnings.</p>"},{"location":"configuration/#default-behavior-no-config-file","title":"Default Behavior (No Config File)","text":"<p>If you don't provide an <code>oak_config.yaml</code> file, the validator uses intelligent defaults:</p> <p>Default adapter: <code>sqlite:obo:</code></p> <p>The validator automatically creates per-prefix adapters based on the prefix in the CURIE:</p> <ul> <li><code>GO:0008150</code> \u2192 uses <code>sqlite:obo:go</code></li> <li><code>CHEBI:15377</code> \u2192 uses <code>sqlite:obo:chebi</code></li> <li><code>UBERON:0000468</code> \u2192 uses <code>sqlite:obo:uberon</code></li> <li><code>CL:0000540</code> \u2192 uses <code>sqlite:obo:cl</code></li> </ul> <p>This works for any OBO ontology that OAK knows about.</p> <p>When this works well:</p> <ul> <li>You're using standard OBO ontologies (GO, CHEBI, UBERON, CL, etc.)</li> <li>You want all ontology terms validated</li> <li>You're okay with initial download times</li> </ul> <p>When you need a config file:</p> <ul> <li>You want to use different adapters (e.g., OLS instead of SQLite)</li> <li>You want to skip validation for certain prefixes</li> <li>You have custom ontologies not in OBO</li> <li>You want to use local OBO files for testing</li> </ul>"},{"location":"configuration/#command-line-options","title":"Command-Line Options","text":""},{"location":"configuration/#cache-control","title":"Cache Control","text":"<p>Cache directory:</p> <pre><code>linkml-term-validator validate-schema --cache-dir /path/to/cache schema.yaml\n</code></pre> <p>Default: <code>./cache</code></p> <p>Disable caching:</p> <pre><code>linkml-term-validator validate-schema --no-cache schema.yaml\n</code></pre> <p>This forces fresh lookups from the ontology source every time. Useful for testing or when you want guaranteed fresh data.</p>"},{"location":"configuration/#validation-behavior","title":"Validation Behavior","text":"<p>Strict mode:</p> <pre><code>linkml-term-validator validate-schema --strict schema.yaml\n</code></pre> <p>Treats all warnings as errors. Useful for CI/CD pipelines where you want strict enforcement.</p> <p>Verbose output:</p> <pre><code>linkml-term-validator validate-schema --verbose schema.yaml\n</code></pre> <p>Shows detailed information about what's being validated and any issues encountered.</p> <p>Label validation (data validation only):</p> <pre><code>linkml-term-validator validate-data --labels data.yaml --schema schema.yaml\n</code></pre> <p>Also validates that labels in the data match the canonical labels from the ontology.</p> <p>Selective plugin usage (data validation only):</p> <pre><code># Only validate dynamic enums, skip bindings\nlinkml-term-validator validate-data --no-bindings data.yaml --schema schema.yaml\n\n# Only validate bindings, skip dynamic enums\nlinkml-term-validator validate-data --no-dynamic-enums data.yaml --schema schema.yaml\n</code></pre>"},{"location":"configuration/#example-configurations","title":"Example Configurations","text":""},{"location":"configuration/#standard-obo-ontologies","title":"Standard OBO Ontologies","text":"<pre><code># oak_config.yaml\nontology_adapters:\n  GO: sqlite:obo:go\n  CHEBI: sqlite:obo:chebi\n  UBERON: sqlite:obo:uberon\n  CL: sqlite:obo:cl\n  MONDO: sqlite:obo:mondo\n  HP: sqlite:obo:hp\n</code></pre>"},{"location":"configuration/#mixed-onlineoffline","title":"Mixed Online/Offline","text":"<pre><code># oak_config.yaml\nontology_adapters:\n  # Use SQLite for commonly-used ontologies\n  GO: sqlite:obo:go\n  CHEBI: sqlite:obo:chebi\n\n  # Use OLS for rarely-used ontologies (avoid downloads)\n  FYPO: ols:\n  WBPhenotype: ols:\n\n  # Skip validation for metadata prefixes\n  linkml: \"\"\n  schema: \"\"\n</code></pre>"},{"location":"configuration/#local-testing-setup","title":"Local Testing Setup","text":"<pre><code># oak_config.yaml (for tests)\nontology_adapters:\n  # Use local OBO file for fast, offline testing\n  TEST: simpleobo:tests/data/test_ontology.obo\n\n  # Real ontologies for integration tests\n  GO: sqlite:obo:go\n</code></pre>"},{"location":"configuration/#custom-ontology","title":"Custom Ontology","text":"<pre><code># oak_config.yaml\nontology_adapters:\n  # Standard ontologies\n  GO: sqlite:obo:go\n  CHEBI: sqlite:obo:chebi\n\n  # Your custom ontology from local file\n  MY_ORG: simpleobo:ontologies/my_org_ontology.obo\n</code></pre>"},{"location":"configuration/#cicd-pipeline","title":"CI/CD Pipeline","text":"<p>For CI/CD, you typically want:</p> <ul> <li>Strict mode - treat warnings as errors</li> <li>Configured adapters - control which ontologies are validated</li> <li>Caching - cache between runs for speed</li> </ul> <p>GitHub Actions example:</p> <pre><code># .github/workflows/validate.yml\nname: Validate Schemas\n\non: [push, pull_request]\n\njobs:\n  validate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.10'\n\n      - name: Install dependencies\n        run: |\n          pip install linkml-term-validator\n\n      - name: Cache ontology databases\n        uses: actions/cache@v3\n        with:\n          path: cache\n          key: ontology-cache-${{ hashFiles('oak_config.yaml') }}\n\n      - name: Validate schemas\n        run: |\n          linkml-term-validator validate-schema \\\n            --strict \\\n            --config oak_config.yaml \\\n            --cache-dir cache \\\n            src/schema/\n</code></pre>"},{"location":"configuration/#plugin-configuration-python-api","title":"Plugin Configuration (Python API)","text":"<p>When using plugins programmatically, you can configure them via constructor arguments:</p>"},{"location":"configuration/#permissiblevaluemeaningplugin","title":"PermissibleValueMeaningPlugin","text":"<pre><code>from linkml_term_validator.plugins import PermissibleValueMeaningPlugin\n\nplugin = PermissibleValueMeaningPlugin(\n    oak_adapter_string=\"sqlite:obo:\",  # Default adapter\n    oak_config_path=\"oak_config.yaml\",  # Optional config file\n    strict_mode=False,                   # Treat warnings as errors\n    cache_labels=True,                   # Enable file-based caching\n    cache_dir=\"cache\",                   # Cache directory\n)\n</code></pre>"},{"location":"configuration/#dynamicenumplugin","title":"DynamicEnumPlugin","text":"<pre><code>from linkml_term_validator.plugins import DynamicEnumPlugin\n\nplugin = DynamicEnumPlugin(\n    oak_adapter_string=\"sqlite:obo:\",\n    oak_config_path=\"oak_config.yaml\",\n    cache_labels=True,\n    cache_dir=\"cache\",\n)\n</code></pre>"},{"location":"configuration/#bindingvalidationplugin","title":"BindingValidationPlugin","text":"<pre><code>from linkml_term_validator.plugins import BindingValidationPlugin\n\nplugin = BindingValidationPlugin(\n    oak_adapter_string=\"sqlite:obo:\",\n    oak_config_path=\"oak_config.yaml\",\n    validate_labels=True,  # Also check labels match ontology\n    cache_labels=True,\n    cache_dir=\"cache\",\n)\n</code></pre>"},{"location":"configuration/#linkml-validate-configuration","title":"linkml-validate Configuration","text":"<p>When using plugins with <code>linkml-validate</code>, configure them via YAML:</p> <pre><code># validation_config.yaml\nschema: schema.yaml\ntarget_class: Person\n\ndata_sources:\n  - data.yaml\n\nplugins:\n  JsonschemaValidationPlugin:\n    closed: true\n\n  \"linkml_term_validator.plugins.DynamicEnumPlugin\":\n    oak_adapter_string: \"sqlite:obo:\"\n    cache_labels: true\n    cache_dir: cache\n    oak_config_path: oak_config.yaml\n\n  \"linkml_term_validator.plugins.BindingValidationPlugin\":\n    oak_adapter_string: \"sqlite:obo:\"\n    validate_labels: true\n    cache_labels: true\n    cache_dir: cache\n    oak_config_path: oak_config.yaml\n</code></pre> <p>Then:</p> <pre><code>linkml-validate --config validation_config.yaml\n</code></pre>"},{"location":"configuration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"configuration/#unknown-prefix-warnings","title":"\"Unknown prefix\" warnings","text":"<p>Symptom: You see warnings like:</p> <pre><code>\u26a0\ufe0f  Unknown prefixes encountered (validation skipped):\n  - MY_CUSTOM\n  - SOME_ONTOLOGY\n</code></pre> <p>Cause: These prefixes aren't in your <code>oak_config.yaml</code> (or you're not using a config file and OAK doesn't recognize them).</p> <p>Solution: Add them to your config file:</p> <pre><code>ontology_adapters:\n  MY_CUSTOM: simpleobo:path/to/ontology.obo\n  SOME_ONTOLOGY: sqlite:obo:some_ontology\n</code></pre> <p>Or, if you don't want to validate them, explicitly skip:</p> <pre><code>ontology_adapters:\n  MY_CUSTOM: \"\"\n</code></pre>"},{"location":"configuration/#downloading-mydbgz-errors","title":"\"Downloading my.db.gz\" errors","text":"<p>Symptom: Long download times or errors downloading ontology databases.</p> <p>Cause: Using <code>sqlite:obo:</code> adapter for the first time with a new ontology.</p> <p>Solutions:</p> <ol> <li>Be patient - first download can take 5-10 minutes for large ontologies</li> <li>Use local files for testing - switch to <code>simpleobo:</code> for unit tests</li> <li>Pre-download in CI/CD - cache the <code>cache/</code> directory between runs</li> <li>Use OLS - switch to <code>ols:</code> adapter to avoid downloads</li> </ol>"},{"location":"configuration/#stale-cache-data","title":"Stale cache data","text":"<p>Symptom: Validation shows old labels even though ontology has been updated.</p> <p>Cause: File-based cache hasn't been refreshed.</p> <p>Solution:</p> <pre><code># Clear cache and re-validate\nrm -rf cache/\nlinkml-term-validator validate-schema schema.yaml\n</code></pre> <p>Or use <code>--no-cache</code> to bypass caching:</p> <pre><code>linkml-term-validator validate-schema --no-cache schema.yaml\n</code></pre>"},{"location":"ontology-access/","title":"Ontology Access","text":"<p>All linkml-term-validator plugins use OAK (Ontology Access Kit) to access ontology data.</p>"},{"location":"ontology-access/#oak-adapters","title":"OAK Adapters","text":"<p>An adapter is OAK's abstraction for accessing ontology sources. Different adapters support different backends:</p> <ul> <li><code>sqlite:obo:</code> - Pre-downloaded OBO ontologies in SQLite format (default, fast, offline)</li> <li><code>simpleobo:</code> - Simple local OBO files (good for unit tests)</li> <li><code>ols:</code> - Ontology Lookup Service (online, no local download required)</li> <li><code>bioportal:</code> - NCBO BioPortal (requires API key)</li> <li><code>ubergraph:</code> - Ubergraph SPARQL endpoint</li> </ul>"},{"location":"ontology-access/#default-behavior","title":"Default Behavior","text":"<p>Without configuration, the validator uses <code>sqlite:obo:</code> as the default adapter, which automatically creates per-prefix adapters:</p> <ul> <li><code>GO:0008150</code> \u2192 uses <code>sqlite:obo:go</code></li> <li><code>CHEBI:15377</code> \u2192 uses <code>sqlite:obo:chebi</code></li> <li><code>UBERON:0000468</code> \u2192 uses <code>sqlite:obo:uberon</code></li> </ul> <p>This works for any OBO ontology that has been downloaded via OAK.</p>"},{"location":"ontology-access/#per-prefix-configuration","title":"Per-Prefix Configuration","text":"<p>You can override the adapter for specific prefixes using an <code>oak_config.yaml</code> file:</p> <pre><code>ontology_adapters:\n  GO: sqlite:obo:go           # Use local GO database\n  CHEBI: ols:                 # Use OLS for CHEBI\n  MY_CUSTOM: simpleobo:my_ontology.obo  # Use local OBO file\n  SKIP_THIS: \"\"               # Skip validation for this prefix\n</code></pre> <p>Important: When using <code>oak_config.yaml</code>, ONLY the prefixes listed in the config will be validated. Unlisted prefixes are reported as \"unknown.\"</p>"},{"location":"ontology-access/#using-the-config-file","title":"Using the Config File","text":"<p>CLI:</p> <pre><code>linkml-term-validator validate-schema --config oak_config.yaml schema.yaml\nlinkml-term-validator validate-data --config oak_config.yaml data.yaml --schema schema.yaml\n</code></pre> <p>Python API:</p> <pre><code>from linkml_term_validator.plugins import PermissibleValueMeaningPlugin\n\nplugin = PermissibleValueMeaningPlugin(oak_config_path=\"oak_config.yaml\")\n</code></pre>"},{"location":"ontology-access/#adapter-details","title":"Adapter Details","text":""},{"location":"ontology-access/#sqliteobo-recommended","title":"sqlite:obo: (Recommended)","text":"<p>Uses pre-downloaded OBO ontologies in SQLite format.</p> <p>Pros: - Fast queries (SQLite is efficient) - Works offline after initial download - No rate limiting - Consistent results</p> <p>Cons: - Requires initial download - Takes disk space (~100MB-1GB per ontology) - Need to manually update for latest ontology versions</p> <p>First-time setup:</p> <p>The first time you validate with a new ontology, OAK will download and build the SQLite database. This can take a few minutes but only happens once.</p>"},{"location":"ontology-access/#simpleobo","title":"simpleobo:","text":"<p>Uses local OBO files directly. Ideal for unit tests and custom ontologies.</p> <p>Usage:</p> <pre><code>ontology_adapters:\n  MY_CUSTOM: simpleobo:path/to/my_ontology.obo\n  TEST: simpleobo:tests/data/test_ontology.obo\n</code></pre> <p>Pros: - Fast, lightweight - Perfect for testing - No network access required - Full control over ontology version</p> <p>Cons: - Limited query capabilities compared to SQLite - Only works with OBO format - Need to manage OBO files yourself</p>"},{"location":"ontology-access/#ols","title":"ols:","text":"<p>Uses the Ontology Lookup Service (EBI). Online service, no local downloads.</p> <p>Usage:</p> <pre><code>ontology_adapters:\n  GO: ols:\n  CHEBI: ols:\n</code></pre> <p>Pros: - No local downloads - Always uses latest ontology versions - Works out-of-the-box</p> <p>Cons: - Requires internet connection - Slower than local adapters - Subject to rate limiting - Service availability dependence</p>"},{"location":"ontology-access/#bioportal","title":"bioportal:","text":"<p>Uses NCBO BioPortal. Requires API key.</p> <p>Setup:</p> <p>Set <code>BIOPORTAL_API_KEY</code> environment variable:</p> <pre><code>export BIOPORTAL_API_KEY=your-api-key-here\nlinkml-term-validator validate-schema --config oak_config.yaml schema.yaml\n</code></pre> <p>Usage:</p> <pre><code>ontology_adapters:\n  GO: bioportal:\n  CHEBI: bioportal:\n</code></pre>"},{"location":"ontology-access/#unknown-prefixes","title":"Unknown Prefixes","text":"<p>When the validator encounters a prefix it doesn't recognize (not in <code>oak_config.yaml</code> or not a known OBO ontology), it:</p> <ol> <li>Logs a warning</li> <li>Skips validation for that term</li> <li>Reports unknown prefixes at the end of validation</li> </ol> <p>Example output:</p> <pre><code>\u26a0\ufe0f  Unknown prefixes encountered (validation skipped):\n  - MY_CUSTOM\n  - INTERNAL\n\nConsider adding these to oak_config.yaml to enable validation.\n</code></pre> <p>To fix: Add them to your <code>oak_config.yaml</code>:</p> <pre><code>ontology_adapters:\n  MY_CUSTOM: simpleobo:path/to/ontology.obo\n  INTERNAL: \"\"  # Or empty string to explicitly skip\n</code></pre>"},{"location":"ontology-access/#see-also","title":"See Also","text":"<ul> <li>Configuration - Complete configuration guide</li> <li>Caching - How ontology data is cached</li> <li>Validation Types - Understanding the validation plugins</li> </ul>"},{"location":"plugin-reference/","title":"Plugin Reference","text":"<p>This page provides complete API reference documentation for the three LinkML ValidationPlugin implementations provided by linkml-term-validator.</p> <p>All plugins are designed to work with the LinkML Validator framework and can be used standalone or composed together.</p>"},{"location":"plugin-reference/#permissiblevaluemeaningplugin","title":"PermissibleValueMeaningPlugin","text":"<p>Validates that <code>meaning</code> fields in enum permissible values reference valid ontology terms with correct labels.</p> <p>Module: <code>linkml_term_validator.plugins.permissible_value_meaning_plugin</code></p>"},{"location":"plugin-reference/#constructor","title":"Constructor","text":"<pre><code>from linkml_term_validator.plugins import PermissibleValueMeaningPlugin\n\nplugin = PermissibleValueMeaningPlugin(\n    oak_adapter_string=\"sqlite:obo:\",\n    oak_config_path=None,\n    strict_mode=False,\n    cache_labels=True,\n    cache_dir=\"cache\",\n)\n</code></pre>"},{"location":"plugin-reference/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>oak_adapter_string</code> <code>str</code> <code>\"sqlite:obo:\"</code> Default OAK adapter string for ontology access <code>oak_config_path</code> <code>str \\| None</code> <code>None</code> Path to <code>oak_config.yaml</code> for per-prefix adapter configuration <code>strict_mode</code> <code>bool</code> <code>False</code> If <code>True</code>, treat all warnings as errors <code>cache_labels</code> <code>bool</code> <code>True</code> Enable file-based caching of ontology labels <code>cache_dir</code> <code>str</code> <code>\"cache\"</code> Directory for cache files"},{"location":"plugin-reference/#usage","title":"Usage","text":"<p>Basic usage:</p> <pre><code>from linkml.validator import Validator\nfrom linkml_term_validator.plugins import PermissibleValueMeaningPlugin\n\n# Create plugin\nplugin = PermissibleValueMeaningPlugin()\n\n# Create validator with plugin\nvalidator = Validator(\n    schema=\"schema.yaml\",\n    validation_plugins=[plugin]\n)\n\n# Validate schema file\nreport = validator.validate_file(\"schema.yaml\")\n\n# Check results\nif len(report.results) == 0:\n    print(\"\u2705 All permissible values validated successfully\")\nelse:\n    for result in report.results:\n        print(f\"{result.severity.name}: {result.message}\")\n</code></pre> <p>With custom configuration:</p> <pre><code>plugin = PermissibleValueMeaningPlugin(\n    oak_config_path=\"oak_config.yaml\",\n    strict_mode=True,\n    cache_dir=\"custom_cache\"\n)\n</code></pre> <p>With OLS adapter:</p> <pre><code>plugin = PermissibleValueMeaningPlugin(\n    oak_adapter_string=\"ols:\",\n    cache_labels=False  # Don't cache when using online service\n)\n</code></pre>"},{"location":"plugin-reference/#what-it-validates","title":"What It Validates","text":"<p>For each enum in the schema:</p> <ol> <li>Extracts all permissible values with <code>meaning</code> fields</li> <li>For each meaning CURIE (e.g., <code>GO:0008150</code>):</li> <li>Retrieves the canonical label from the ontology</li> <li>Compares against expected labels from the schema</li> <li>Reports mismatches or missing terms</li> </ol> <p>Expected labels are derived from:</p> <ul> <li>Permissible value name (e.g., <code>BIOLOGICAL_PROCESS</code>)</li> <li><code>title</code> field</li> <li><code>description</code> field</li> <li><code>aliases</code> list</li> <li>Annotation values for tags like <code>label</code>, <code>display_name</code>, <code>synonym</code></li> </ul>"},{"location":"plugin-reference/#validation-results","title":"Validation Results","text":"<p>Results use LinkML's <code>ValidationResult</code> class with the following severity levels:</p> Severity Condition <code>ERROR</code> Label mismatch for configured prefix (or any prefix in strict mode) <code>WARN</code> Label mismatch for unconfigured prefix (non-strict mode) <code>INFO</code> Missing term from unconfigured prefix"},{"location":"plugin-reference/#example","title":"Example","text":"<p>Schema:</p> <pre><code>enums:\n  BiologicalProcessEnum:\n    permissible_values:\n      BIOLOGICAL_PROCESS:\n        title: biological process\n        meaning: GO:0008150\n      CELL_CYCLE:\n        title: cell cycle\n        meaning: GO:0007049\n</code></pre> <p>Code:</p> <pre><code>from linkml.validator import Validator\nfrom linkml_term_validator.plugins import PermissibleValueMeaningPlugin\n\nplugin = PermissibleValueMeaningPlugin()\nvalidator = Validator(schema=\"schema.yaml\", validation_plugins=[plugin])\nreport = validator.validate_file(\"schema.yaml\")\n\nprint(f\"Validated {len(report.results)} permissible values\")\n</code></pre>"},{"location":"plugin-reference/#dynamicenumplugin","title":"DynamicEnumPlugin","text":"<p>Validates data values against dynamic enum constraints defined via <code>reachable_from</code>, <code>matches</code>, or <code>concepts</code>.</p> <p>Module: <code>linkml_term_validator.plugins.dynamic_enum_plugin</code></p>"},{"location":"plugin-reference/#constructor_1","title":"Constructor","text":"<pre><code>from linkml_term_validator.plugins import DynamicEnumPlugin\n\nplugin = DynamicEnumPlugin(\n    oak_adapter_string=\"sqlite:obo:\",\n    oak_config_path=None,\n    cache_labels=True,\n    cache_dir=\"cache\",\n)\n</code></pre>"},{"location":"plugin-reference/#parameters_1","title":"Parameters","text":"Parameter Type Default Description <code>oak_adapter_string</code> <code>str</code> <code>\"sqlite:obo:\"</code> Default OAK adapter string for ontology access <code>oak_config_path</code> <code>str \\| None</code> <code>None</code> Path to <code>oak_config.yaml</code> for per-prefix adapter configuration <code>cache_labels</code> <code>bool</code> <code>True</code> Enable file-based caching of ontology labels <code>cache_dir</code> <code>str</code> <code>\"cache\"</code> Directory for cache files"},{"location":"plugin-reference/#usage_1","title":"Usage","text":"<p>Basic usage:</p> <pre><code>from linkml.validator import Validator\nfrom linkml_term_validator.plugins import DynamicEnumPlugin\n\n# Create plugin\nplugin = DynamicEnumPlugin()\n\n# Create validator\nvalidator = Validator(\n    schema=\"schema.yaml\",\n    validation_plugins=[plugin]\n)\n\n# Validate data file\nreport = validator.validate_file(\"data.yaml\")\n\n# Check results\nif len(report.results) == 0:\n    print(\"\u2705 All dynamic enum constraints satisfied\")\nelse:\n    for result in report.results:\n        print(f\"{result.severity.name}: {result.message}\")\n</code></pre> <p>With YamlLoader (recommended for YAML data):</p> <pre><code>from linkml.validator import Validator\nfrom linkml_runtime.loaders import yaml_loader\nfrom linkml_term_validator.plugins import DynamicEnumPlugin\n\nplugin = DynamicEnumPlugin()\nvalidator = Validator(schema=\"schema.yaml\", validation_plugins=[plugin])\n\nloader = yaml_loader.YamlLoader()\nreport = validator.validate_source(loader, \"data.yaml\", target_class=\"Person\")\n</code></pre>"},{"location":"plugin-reference/#what-it-validates_1","title":"What It Validates","text":"<p>For each slot in the data with a dynamic enum range:</p> <ol> <li>Checks if the value satisfies the enum constraint</li> <li>For <code>reachable_from</code>: validates value is a descendant of source nodes</li> <li>For <code>matches</code>: validates value matches the specified pattern</li> <li>For <code>concepts</code>: validates value is one of the specified concepts</li> </ol> <p>Important semantics:</p> <ul> <li>For <code>reachable_from</code>, source nodes themselves are EXCLUDED by default</li> <li>Only descendants (via specified relationship types) are included</li> </ul>"},{"location":"plugin-reference/#validation-results_1","title":"Validation Results","text":"Severity Condition <code>ERROR</code> Value does not satisfy dynamic enum constraint"},{"location":"plugin-reference/#example_1","title":"Example","text":"<p>Schema:</p> <pre><code>classes:\n  Neuron:\n    attributes:\n      cell_type:\n        range: NeuronTypeEnum\n\nenums:\n  NeuronTypeEnum:\n    reachable_from:\n      source_ontology: sqlite:obo:cl\n      source_nodes:\n        - CL:0000540  # neuron\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre> <p>Data:</p> <pre><code>neurons:\n  - cell_type: CL:0000100  # Valid - descendant of CL:0000540\n  - cell_type: GO:0008150  # INVALID - not a neuron type\n</code></pre> <p>Code:</p> <pre><code>from linkml.validator import Validator\nfrom linkml_runtime.loaders import yaml_loader\nfrom linkml_term_validator.plugins import DynamicEnumPlugin\n\nplugin = DynamicEnumPlugin()\nvalidator = Validator(schema=\"schema.yaml\", validation_plugins=[plugin])\n\nloader = yaml_loader.YamlLoader()\nreport = validator.validate_source(loader, \"neurons.yaml\", target_class=\"Neuron\")\n\n# Will show ERROR for GO:0008150\nfor result in report.results:\n    print(f\"{result.severity.name}: {result.message}\")\n</code></pre>"},{"location":"plugin-reference/#bindingvalidationplugin","title":"BindingValidationPlugin","text":"<p>Validates that nested object fields satisfy binding range constraints, optionally checking labels match ontology.</p> <p>Module: <code>linkml_term_validator.plugins.binding_validation_plugin</code></p>"},{"location":"plugin-reference/#constructor_2","title":"Constructor","text":"<pre><code>from linkml_term_validator.plugins import BindingValidationPlugin\n\nplugin = BindingValidationPlugin(\n    oak_adapter_string=\"sqlite:obo:\",\n    oak_config_path=None,\n    validate_labels=False,\n    cache_labels=True,\n    cache_dir=\"cache\",\n)\n</code></pre>"},{"location":"plugin-reference/#parameters_2","title":"Parameters","text":"Parameter Type Default Description <code>oak_adapter_string</code> <code>str</code> <code>\"sqlite:obo:\"</code> Default OAK adapter string for ontology access <code>oak_config_path</code> <code>str \\| None</code> <code>None</code> Path to <code>oak_config.yaml</code> for per-prefix adapter configuration <code>validate_labels</code> <code>bool</code> <code>False</code> If <code>True</code>, also validate that labels match ontology canonical labels <code>cache_labels</code> <code>bool</code> <code>True</code> Enable file-based caching of ontology labels <code>cache_dir</code> <code>str</code> <code>\"cache\"</code> Directory for cache files"},{"location":"plugin-reference/#usage_2","title":"Usage","text":"<p>Basic usage (binding validation only):</p> <pre><code>from linkml.validator import Validator\nfrom linkml_term_validator.plugins import BindingValidationPlugin\n\n# Create plugin without label validation\nplugin = BindingValidationPlugin()\n\nvalidator = Validator(\n    schema=\"schema.yaml\",\n    validation_plugins=[plugin]\n)\n\nreport = validator.validate_file(\"data.yaml\")\n</code></pre> <p>With label validation (anti-hallucination mode):</p> <pre><code># Enable label validation for AI-generated data\nplugin = BindingValidationPlugin(validate_labels=True)\n\nvalidator = Validator(schema=\"schema.yaml\", validation_plugins=[plugin])\nreport = validator.validate_file(\"ai_generated_data.yaml\")\n\n# Will catch both binding violations AND label mismatches\nfor result in report.results:\n    print(f\"{result.severity.name}: {result.message}\")\n</code></pre> <p>With custom configuration:</p> <pre><code>plugin = BindingValidationPlugin(\n    oak_config_path=\"oak_config.yaml\",\n    validate_labels=True,\n    cache_dir=\"custom_cache\"\n)\n</code></pre>"},{"location":"plugin-reference/#what-it-validates_2","title":"What It Validates","text":"<p>For each slot with binding constraints:</p> <ol> <li>Binding constraint validation (always):</li> <li>Checks that the value in the nested object's field satisfies the binding's range constraint</li> <li> <p>Range is typically a dynamic enum (e.g., only biological processes, only neuron types)</p> </li> <li> <p>Label validation (if <code>validate_labels=True</code>):</p> </li> <li>Retrieves the canonical label from the ontology</li> <li>Compares against the label provided in the data</li> <li>Reports mismatches</li> </ol>"},{"location":"plugin-reference/#validation-results_2","title":"Validation Results","text":"Severity Condition <code>ERROR</code> Binding constraint violated <code>ERROR</code> Label mismatch (if <code>validate_labels=True</code>) <code>WARN</code> Label mismatch for unconfigured prefix (if <code>validate_labels=True</code>)"},{"location":"plugin-reference/#example_2","title":"Example","text":"<p>Schema:</p> <pre><code>classes:\n  GeneAnnotation:\n    attributes:\n      gene:\n        range: string\n      go_term:\n        range: GOTerm\n        bindings:\n          - binds_value_of: id\n            range: BiologicalProcessEnum\n\n  GOTerm:\n    attributes:\n      id:\n        range: string\n      label:\n        range: string\n\nenums:\n  BiologicalProcessEnum:\n    reachable_from:\n      source_ontology: sqlite:obo:go\n      source_nodes:\n        - GO:0008150  # biological_process\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre> <p>Data:</p> <pre><code>annotations:\n  - gene: BRCA1\n    go_term:\n      id: GO:0007049  # Valid - is a biological process\n      label: cell cycle\n  - gene: EGFR\n    go_term:\n      id: GO:0005575  # INVALID - cellular_component, not a process\n      label: cellular_component\n</code></pre> <p>Code:</p> <pre><code>from linkml.validator import Validator\nfrom linkml_runtime.loaders import yaml_loader\nfrom linkml_term_validator.plugins import BindingValidationPlugin\n\n# With label validation enabled\nplugin = BindingValidationPlugin(validate_labels=True)\nvalidator = Validator(schema=\"schema.yaml\", validation_plugins=[plugin])\n\nloader = yaml_loader.YamlLoader()\nreport = validator.validate_source(\n    loader,\n    \"annotations.yaml\",\n    target_class=\"GeneAnnotation\"\n)\n\n# Will show ERROR for GO:0005575 (wrong category)\n# Will also validate that labels match ontology\nfor result in report.results:\n    print(f\"{result.severity.name}: {result.message}\")\n</code></pre>"},{"location":"plugin-reference/#composing-multiple-plugins","title":"Composing Multiple Plugins","text":"<p>You can use multiple plugins together for comprehensive validation:</p> <pre><code>from linkml.validator import Validator\nfrom linkml.validator.plugins import JsonschemaValidationPlugin\nfrom linkml_term_validator.plugins import (\n    DynamicEnumPlugin,\n    BindingValidationPlugin,\n)\n\n# Build validation pipeline\nplugins = [\n    JsonschemaValidationPlugin(closed=True),  # Structural validation\n    DynamicEnumPlugin(),                       # Dynamic enum validation\n    BindingValidationPlugin(validate_labels=True),  # Binding + label validation\n]\n\n# Create validator with all plugins\nvalidator = Validator(\n    schema=\"schema.yaml\",\n    validation_plugins=plugins\n)\n\n# Validate data\nreport = validator.validate_file(\"data.yaml\")\n\n# Check results\nif len(report.results) == 0:\n    print(\"\u2705 All validations passed\")\nelse:\n    # Group results by severity\n    errors = [r for r in report.results if r.severity.name == \"ERROR\"]\n    warnings = [r for r in report.results if r.severity.name == \"WARN\"]\n\n    print(f\"Errors: {len(errors)}\")\n    print(f\"Warnings: {len(warnings)}\")\n\n    for result in report.results:\n        print(f\"{result.severity.name}: {result.message}\")\n</code></pre>"},{"location":"plugin-reference/#integration-with-linkml-validate","title":"Integration with linkml-validate","text":"<p>All plugins can be used with the standard <code>linkml-validate</code> command via configuration files.</p> <p>Configuration file:</p> <pre><code># validation_config.yaml\nschema: schema.yaml\ntarget_class: Person\n\ndata_sources:\n  - data.yaml\n\nplugins:\n  # Standard LinkML validation\n  JsonschemaValidationPlugin:\n    closed: true\n\n  # Dynamic enum validation\n  \"linkml_term_validator.plugins.DynamicEnumPlugin\":\n    oak_adapter_string: \"sqlite:obo:\"\n    cache_labels: true\n    cache_dir: cache\n\n  # Binding validation with label checking\n  \"linkml_term_validator.plugins.BindingValidationPlugin\":\n    oak_adapter_string: \"sqlite:obo:\"\n    validate_labels: true\n    cache_labels: true\n    cache_dir: cache\n</code></pre> <p>Run validation:</p> <pre><code>linkml-validate --config validation_config.yaml\n</code></pre>"},{"location":"plugin-reference/#advanced-usage","title":"Advanced Usage","text":""},{"location":"plugin-reference/#custom-validation-workflow","title":"Custom Validation Workflow","text":"<pre><code>from linkml.validator import Validator\nfrom linkml_runtime.loaders import yaml_loader\nfrom linkml_term_validator.plugins import (\n    DynamicEnumPlugin,\n    BindingValidationPlugin,\n)\n\n# Build custom validation pipeline\ndef validate_ai_generated_data(data_path, schema_path):\n    \"\"\"Validate AI-generated data with anti-hallucination checks.\"\"\"\n\n    plugins = [\n        DynamicEnumPlugin(oak_adapter_string=\"sqlite:obo:\"),\n        BindingValidationPlugin(\n            validate_labels=True,  # Enable label checking\n            oak_adapter_string=\"sqlite:obo:\"\n        ),\n    ]\n\n    validator = Validator(schema=schema_path, validation_plugins=plugins)\n    loader = yaml_loader.YamlLoader()\n\n    report = validator.validate_source(\n        loader,\n        data_path,\n        target_class=\"GeneAnnotation\"\n    )\n\n    # Fail fast on any errors\n    if len(report.results) &gt; 0:\n        errors = [r for r in report.results if r.severity.name == \"ERROR\"]\n        if errors:\n            raise ValueError(f\"Validation failed with {len(errors)} error(s)\")\n\n    return report\n\n# Use in AI pipeline\ntry:\n    report = validate_ai_generated_data(\n        \"ai_output.yaml\",\n        \"schema.yaml\"\n    )\n    print(\"\u2705 AI-generated data validated successfully\")\nexcept ValueError as e:\n    print(f\"\u274c {e}\")\n    # Retry AI generation or fail\n</code></pre>"},{"location":"plugin-reference/#accessing-validator-state","title":"Accessing Validator State","text":"<pre><code>from linkml_term_validator.plugins import DynamicEnumPlugin\n\nplugin = DynamicEnumPlugin()\n\n# Access the OAK validator (for advanced use cases)\noak_validator = plugin.get_validator()\n\n# Check unknown prefixes encountered during validation\nunknown_prefixes = oak_validator.get_unknown_prefixes()\nif unknown_prefixes:\n    print(\"Unknown prefixes encountered:\")\n    for prefix in unknown_prefixes:\n        print(f\"  - {prefix}\")\n</code></pre>"},{"location":"plugin-reference/#testing-plugins","title":"Testing Plugins","text":"<pre><code>import pytest\nfrom linkml.validator import Validator\nfrom linkml_term_validator.plugins import DynamicEnumPlugin\n\ndef test_dynamic_enum_validation():\n    \"\"\"Test dynamic enum validation with local OBO file.\"\"\"\n\n    plugin = DynamicEnumPlugin(\n        oak_config_path=\"tests/data/test_oak_config.yaml\"\n    )\n\n    validator = Validator(\n        schema=\"tests/data/dynamic_enum_schema.yaml\",\n        validation_plugins=[plugin]\n    )\n\n    report = validator.validate_file(\"tests/data/valid_data.yaml\")\n\n    # Should have no errors\n    assert len(report.results) == 0\n\ndef test_invalid_dynamic_enum():\n    \"\"\"Test that invalid values are caught.\"\"\"\n\n    plugin = DynamicEnumPlugin(\n        oak_config_path=\"tests/data/test_oak_config.yaml\"\n    )\n\n    validator = Validator(\n        schema=\"tests/data/dynamic_enum_schema.yaml\",\n        validation_plugins=[plugin]\n    )\n\n    report = validator.validate_file(\"tests/data/invalid_data.yaml\")\n\n    # Should have errors\n    errors = [r for r in report.results if r.severity.name == \"ERROR\"]\n    assert len(errors) &gt; 0\n</code></pre>"},{"location":"plugin-reference/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Command-line usage</li> <li>Configuration - Configuring OAK adapters</li> <li>Validation Types - Understanding validation types</li> <li>Anti-Hallucination Guardrails - Preventing AI hallucinations</li> <li>Tutorials - Interactive Python API tutorial</li> </ul>"},{"location":"validation-types/","title":"Validation Types","text":"<p>linkml-term-validator provides three distinct types of validation, each implemented as a composable LinkML ValidationPlugin.</p>"},{"location":"validation-types/#schema-validation-permissible-values","title":"Schema Validation (Permissible Values)","text":"<p>Plugin: <code>PermissibleValueMeaningPlugin</code></p> <p>Validates that <code>meaning</code> fields in enum permissible values reference valid ontology terms with correct labels.</p>"},{"location":"validation-types/#what-it-checks","title":"What it checks","text":"<ul> <li>The ontology term exists in the source ontology</li> <li>The term's canonical label matches the expected label from the schema</li> <li>Expected labels can come from: permissible value name, <code>title</code>, <code>description</code>, <code>aliases</code>, or annotation values</li> </ul>"},{"location":"validation-types/#example","title":"Example","text":"<p>Schema:</p> <pre><code>enums:\n  BiologicalProcessEnum:\n    permissible_values:\n      BIOLOGICAL_PROCESS:\n        title: biological process\n        meaning: GO:0008150  # \u2190 Validated\n</code></pre> <p>What gets validated:</p> <ol> <li>Check that <code>GO:0008150</code> exists in the Gene Ontology</li> <li>Retrieve the canonical label from GO (should be \"biological_process\")</li> <li>Compare against expected labels: \"BIOLOGICAL_PROCESS\", \"biological process\"</li> <li>Report if there's a mismatch or if the term doesn't exist</li> </ol>"},{"location":"validation-types/#when-to-use","title":"When to use","text":"<ul> <li>Validating LinkML schemas before publishing</li> <li>CI/CD checks on schema files</li> <li>Catching typos in term references</li> </ul>"},{"location":"validation-types/#commands","title":"Commands","text":"<pre><code># Basic validation\nlinkml-term-validator validate-schema schema.yaml\n\n# With strict mode\nlinkml-term-validator validate-schema --strict schema.yaml\n</code></pre>"},{"location":"validation-types/#dynamic-enum-validation","title":"Dynamic Enum Validation","text":"<p>Plugin: <code>DynamicEnumPlugin</code></p> <p>Validates data values against dynamic enum constraints defined via <code>reachable_from</code>, <code>matches</code>, or <code>concepts</code>.</p> <p>Dynamic enums define valid values using ontology queries rather than explicit lists, enabling flexible, extensible validation.</p>"},{"location":"validation-types/#what-it-checks_1","title":"What it checks","text":"<ul> <li>Data values match the ontology query constraints</li> <li>For <code>reachable_from</code>: value is a descendant of specified source nodes</li> <li>For <code>matches</code>: value matches the specified pattern</li> <li>For <code>concepts</code>: value is one of the specified concepts</li> </ul>"},{"location":"validation-types/#example_1","title":"Example","text":"<p>Schema:</p> <pre><code>enums:\n  NeuronTypeEnum:\n    description: Any neuron type\n    reachable_from:\n      source_ontology: sqlite:obo:cl\n      source_nodes:\n        - CL:0000540  # neuron\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre> <p>Data:</p> <pre><code>neurons:\n  - id: \"1\"\n    cell_type: CL:0000100  # Valid - is a descendant of CL:0000540\n  - id: \"2\"\n    cell_type: GO:0008150  # INVALID - not a neuron type\n</code></pre>"},{"location":"validation-types/#important-semantics","title":"Important semantics","text":"<ul> <li>Source nodes themselves are EXCLUDED by default</li> <li>Only descendants (via specified relationship types) are included</li> <li>Use actual descendant terms in your data, not the source node</li> </ul>"},{"location":"validation-types/#when-to-use_1","title":"When to use","text":"<ul> <li>Validating curated data files</li> <li>Ensuring data conforms to ontology-based constraints</li> <li>Flexible validation without hardcoding all valid values</li> </ul>"},{"location":"validation-types/#commands_1","title":"Commands","text":"<pre><code># Validate data with dynamic enums\nlinkml-term-validator validate-data data.yaml --schema schema.yaml\n\n# With specific target class\nlinkml-term-validator validate-data data.yaml -s schema.yaml -t Person\n</code></pre>"},{"location":"validation-types/#binding-validation","title":"Binding Validation","text":"<p>Plugin: <code>BindingValidationPlugin</code></p> <p>Validates that nested object fields satisfy binding range constraints.</p> <p>Bindings allow you to constrain the values of nested object fields based on dynamic enums, providing type safety for ontology references.</p>"},{"location":"validation-types/#what-it-checks_2","title":"What it checks","text":"<ul> <li>The value in the nested object's field matches the binding's range constraint</li> <li>Optionally: the label in the nested object matches the ontology's canonical label</li> </ul>"},{"location":"validation-types/#example_2","title":"Example","text":"<p>Schema:</p> <pre><code>classes:\n  GeneAnnotation:\n    slots:\n      - gene\n      - go_term\n    slot_usage:\n      go_term:\n        range: GOTerm\n        bindings:\n          - binds_value_of: id\n            range: BiologicalProcessEnum  # \u2190 Binding constraint\n\n  GOTerm:\n    slots:\n      - id\n      - label\n\nenums:\n  BiologicalProcessEnum:\n    reachable_from:\n      source_ontology: sqlite:obo:go\n      source_nodes:\n        - GO:0008150  # biological_process\n      relationship_types:\n        - rdfs:subClassOf\n</code></pre> <p>Data:</p> <pre><code>annotations:\n  - gene: BRCA1\n    go_term:\n      id: GO:0007049  # Valid - is a biological process\n      label: cell cycle\n</code></pre> <p>What gets validated:</p> <ol> <li>Check that <code>go_term.id</code> value (<code>GO:0007049</code>) satisfies the <code>BiologicalProcessEnum</code> constraint</li> <li>If <code>--labels</code> flag is used, also check that <code>go_term.label</code> matches the canonical label from GO</li> </ol>"},{"location":"validation-types/#when-to-use_2","title":"When to use","text":"<ul> <li>Validating complex nested data structures</li> <li>Enforcing ontology constraints on object references</li> <li>Label validation for AI-generated data</li> </ul>"},{"location":"validation-types/#commands_2","title":"Commands","text":"<pre><code># Validate bindings only\nlinkml-term-validator validate-data data.yaml --schema schema.yaml\n\n# Also validate labels match ontology\nlinkml-term-validator validate-data data.yaml --schema schema.yaml --labels\n</code></pre>"},{"location":"validation-types/#label-matching","title":"Label Matching","text":"<p>When validating <code>meaning</code> fields, the validator compares the ontology's canonical label against multiple expected sources:</p> <ol> <li>Permissible value name (e.g., <code>BIOLOGICAL_PROCESS</code>)</li> <li>Title field (e.g., <code>title: biological process</code>)</li> <li>Description field</li> <li>Aliases (e.g., <code>aliases: [biological_process, bio process]</code>)</li> <li>Annotation values for tags like <code>label</code>, <code>display_name</code>, <code>synonym</code></li> </ol> <p>Labels are normalized before comparison:</p> <ul> <li>Lowercased</li> <li>Spaces/underscores treated as equivalent</li> <li>Multiple whitespace collapsed to single space</li> </ul> <p>This flexible matching reduces false positives from minor formatting differences.</p>"},{"location":"validation-types/#severity-levels","title":"Severity Levels","text":"<p>Validation results are reported with different severity levels:</p> <ul> <li>ERROR - Serious issue that should block data/schema acceptance</li> <li>Configured prefix with label mismatch</li> <li>Missing term from configured ontology</li> <li>Dynamic enum constraint violation</li> <li> <p>Binding constraint violation</p> </li> <li> <p>WARN - Potential issue that may need attention</p> </li> <li>Label mismatch in non-strict mode</li> <li> <p>Unconfigured prefix with label mismatch (when verbose)</p> </li> <li> <p>INFO - Informational message</p> </li> <li>Unconfigured prefix encountered</li> <li>Unknown prefix summary</li> </ul>"},{"location":"validation-types/#strict-mode","title":"Strict Mode","text":"<p>Use <code>--strict</code> to treat all warnings as errors:</p> <pre><code>linkml-term-validator validate-schema --strict schema.yaml\n</code></pre>"},{"location":"validation-types/#see-also","title":"See Also","text":"<ul> <li>Configuration - How to configure ontology adapters</li> <li>Caching - Understanding the caching system</li> <li>Anti-Hallucination - Using validation for AI guardrails</li> </ul>"}]}